"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3901],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(r),h=i,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||a;return r?n.createElement(m,o(o({ref:t},c),{},{components:r})):n.createElement(m,o({ref:t},c))}));function m(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var u=2;u<a;u++)o[u]=r[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},8911:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>u});var n=r(7462),i=(r(7294),r(3905));const a={slug:"rust-verification",title:"Verifying Rust: Exploring Verification Options for Substrate",tags:["blockchain","security","software-engineering","rust"],authors:"dom"},o=void 0,s={permalink:"/blog/rust-verification",editUrl:"https://github.com/nud3l/nud3l.github.io/blog/2023-02-20-rust-verification/index.md",source:"@site/blog/2023-02-20-rust-verification/index.md",title:"Verifying Rust: Exploring Verification Options for Substrate",description:"Security is hard to get right in blockchains. It's even harder to make sure that code is correct while still actively developing the product: code changes are frequent, requirements are changing, and the codebase is growing.",date:"2023-02-20T00:00:00.000Z",formattedDate:"February 20, 2023",tags:[{label:"blockchain",permalink:"/blog/tags/blockchain"},{label:"security",permalink:"/blog/tags/security"},{label:"software-engineering",permalink:"/blog/tags/software-engineering"},{label:"rust",permalink:"/blog/tags/rust"}],readingTime:6.95,hasTruncateMarker:!1,authors:[{name:"Dominik Harz",title:"CTO Interlay",url:"https://harz.dev",imageURL:"https://github.com/nud3l.png",key:"dom"}],frontMatter:{slug:"rust-verification",title:"Verifying Rust: Exploring Verification Options for Substrate",tags:["blockchain","security","software-engineering","rust"],authors:"dom"},nextItem:{title:"Lean Execution: How to Stay Focused",permalink:"/blog/lean-execution"}},l={authorsImageUrls:[void 0]},u=[{value:"Substrate Runtimes as Verification Targets",id:"substrate-runtimes-as-verification-targets",level:2},{value:"Diving into Verification",id:"diving-into-verification",level:2},{value:"Selected Tools",id:"selected-tools",level:2},{value:"A Note on Expectations",id:"a-note-on-expectations",level:3},{value:"kani",id:"kani",level:2},{value:"Getting started",id:"getting-started",level:3},{value:"Compilation Errors",id:"compilation-errors",level:3},{value:"Prusti",id:"prusti",level:2},{value:"Getting started",id:"getting-started-1",level:3},{value:"Errors",id:"errors",level:3},{value:"Success",id:"success",level:3},{value:"MIRAI",id:"mirai",level:2},{value:"Getting started",id:"getting-started-2",level:3},{value:"Compilation Errors",id:"compilation-errors-1",level:3},{value:"Success",id:"success-1",level:3},{value:"Summary",id:"summary",level:2}],c={toc:u},p="wrapper";function d(e){let{components:t,...a}=e;return(0,i.kt)(p,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Security is hard to get right in blockchains. It's even harder to make sure that code is correct while still actively developing the product: code changes are frequent, requirements are changing, and the codebase is growing."),(0,i.kt)("p",null,"In this post, we'll explore options for verifying blockchain code, specifically for the Substrate blockchain framework to try to verify the code of the ",(0,i.kt)("a",{parentName:"p",href:"https://www.github.com/interlay/interbtc"},"Interlay blockchain"),". "),(0,i.kt)("p",null,"My requirements for the test were simple: the tool should be integrated into the Rust toolchain (no DSLs) and I set myself a time limit of a single day to get started and get a useful result."),(0,i.kt)("p",null,"Spoiler alert: I managed to get two tools running and produce output. This post covers only the setup and I will follow up with more details in a future post."),(0,i.kt)("h2",{id:"substrate-runtimes-as-verification-targets"},"Substrate Runtimes as Verification Targets"),(0,i.kt)("p",null,"We are building the ",(0,i.kt)("a",{parentName:"p",href:"https://interlay.io"},"Interlay")," and Kintsugi blockchains based on the Rust ",(0,i.kt)("a",{parentName:"p",href:"https://substrate.dev"},"Substrate"),' framework.\nFor verifying that the "code is correct", we are looking for two targets:'),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Runtime"),": The WASM runtime encodes the rules of the blockchain subject to consensus verification. This is where we can potentially introduce logical errors in how the protocols are working or in their implementation such that we either impact the ",(0,i.kt)("em",{parentName:"li"},"safety")," or ",(0,i.kt)("em",{parentName:"li"},"liveness")," of the system."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Node Implementation"),": The node implementation wraps around the runtime. Bugs introduced here can impact the ",(0,i.kt)("em",{parentName:"li"},"liveness")," of the system.")),(0,i.kt)("h2",{id:"diving-into-verification"},"Diving into Verification"),(0,i.kt)("p",null,"Software verification is most often quite an academic exercise. With the adverse environment of blockchain development, there's a clear benefit of increased security assurance in the software development process.\nThis goes hand in hand with the ",(0,i.kt)("a",{parentName:"p",href:"https://alastairreid.github.io/papers/HATRA_20/"},"desire of the verification community to integrate verification into the development process"),"."),(0,i.kt)("p",null,"I'll not cover the usual testing and fuzzing tools but rather explore the three tools I found most accessible for verification in Rust."),(0,i.kt)("p",null,"My criteria for selecting tools were:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Actively maintained"),": The tool should be actively maintained and have a community around it. I checked the GitHub repositories for current contributions and when the last commit was made."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Clear documentation"),": The tool should have clear documentation on how to use it and get started. If after 10 minutes of parsing the available documentation, I could not get a good understanding of how to install or use the tool, I would not use it."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Rust integration"),": Since the idea is to integrate the tool into the normal development workflow, I was looking for a tool that integrates well with ",(0,i.kt)("inlineCode",{parentName:"li"},"cargo")," and also does not require writing verification code in a language other than Rust.")),(0,i.kt)("h2",{id:"selected-tools"},"Selected Tools"),(0,i.kt)("p",null,"From the tools I found, I selected the following three tools for further exploration:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/model-checking/kani"},"kani")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://viperproject.github.io/prusti-dev/"},"Prusti")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/facebookexperimental/MIRAI"},"MIRAI"))),(0,i.kt)("p",null,"More tools are available on the ",(0,i.kt)("a",{parentName:"p",href:"https://rust-formal-methods.github.io/tools.html"},"Rust Formal Methods Interest Group")," website and on ",(0,i.kt)("a",{parentName:"p",href:"https://alastairreid.github.io/automatic-rust-verification-tools-2021/"},"Alastair Reid's blog"),"."),(0,i.kt)("p",null,"For all tools, I installed them and ran them without any additional configuration against the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/interlay/interbtc"},"chain implementation")," of the Interlay blockchain."),(0,i.kt)("h3",{id:"a-note-on-expectations"},"A Note on Expectations"),(0,i.kt)("p",null,"I would be happy if a tool runs on the first try: installing the tool without issues and scanning the code base without setting up verification rules. Overall, the code is well-tested, but it is very complex: more than 1,000 dependencies, almost 100,000 lines of code, and invoking external C libraries."),(0,i.kt)("h2",{id:"kani"},"kani"),(0,i.kt)("p",null,"From the ",(0,i.kt)("a",{parentName:"p",href:"https://model-checking.github.io/kani/getting-started.html"},"developer's website"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Kani is an open-source verification tool that uses model checking to analyze Rust programs. Kani is particularly useful for verifying unsafe code in Rust, where many of the Rust\u2019s usual guarantees are no longer checked by the compiler.")),(0,i.kt)("h3",{id:"getting-started"},"Getting started"),(0,i.kt)("p",null,"I found getting started very easy with just two commands to execute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo install --locked kani-verifier\ncargo kani setup\n")),(0,i.kt)("p",null,"Next, I ran kani against the runtime of the Interlay blockchain:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"# From the interbtc repo root\ncargo kani\n")),(0,i.kt)("h3",{id:"compilation-errors"},"Compilation Errors"),(0,i.kt)("p",null,"That produced the following error during the compilation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"schnorrkel")," crate:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'error: format argument must be a string literal\n   --\x3e /home/nud3l/.cargo/registry/src/github.com-1ecc6299db9ec823/schnorrkel-0.9.1/src/batch.rs:165:47\n    |\n165 |     assert!(hrams.len() == public_keys.len(), ASSERT_MESSAGE);\n    |                                               ^^^^^^^^^^^^^^\n    |\nhelp: you might be missing a string literal to format with\n    |\n165 |     assert!(hrams.len() == public_keys.len(), "{}", ASSERT_MESSAGE);\n    |                                               +++++\n\n')),(0,i.kt)("p",null,"At this point, I wasn't sure how to convince kani to ignore these errors in the dependencies. I tried running kani only on a single crate but it resulted in the same compiler issue."),(0,i.kt)("p",null,"The authors have a guide on how to get started with ",(0,i.kt)("a",{parentName:"p",href:"https://model-checking.github.io/kani/tutorial-real-code.html"},"real code")," but it does not include how to handle compiler errors in dependencies."),(0,i.kt)("h2",{id:"prusti"},"Prusti"),(0,i.kt)("p",null,"From the ",(0,i.kt)("a",{parentName:"p",href:"https://viperproject.github.io/prusti-dev/"},"developer's website"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Prusti is a verification tool for Rust programs. It is based on the Rust compiler and uses the Rust type system to verify Rust programs. Prusti is a research prototype and is not yet ready for production use.")),(0,i.kt)("h3",{id:"getting-started-1"},"Getting started"),(0,i.kt)("p",null,"Getting started with Prusti required downloading the Prusti Assistant VS Code extension.\nI already had the required Java SDk and ",(0,i.kt)("inlineCode",{parentName:"p"},"rustup"),' versions installed so the process of getting started only involved opening a rust file and hitting the "Verify with Prusti" button on the VS Code status bar.'),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Prusti",src:r(7637).Z,width:"774",height:"1079"})),(0,i.kt)("p",null,"As the first target, the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/interlay/interbtc/blob/master/crates/fee/src/lib.rs"},"fee pallet")," seemed interesting as it's mildly complex, has few dependencies, and with its fixed point math might be subject to issues."),(0,i.kt)("h3",{id:"errors"},"Errors"),(0,i.kt)("p",null,"On the first run on the fee crate, Prusti found 358 errors. That seemed quite a lot but after initial inspection, most of the errors were:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Unsupported features (313 errors): I was expecting Prusti with its ",(0,i.kt)("a",{parentName:"li",href:"https://viperproject.github.io/prusti-dev/user-guide/verify/summary.html"},"current feature set")," to run into these issues as substrate makes heavy use of macros, traits, and other advanced features of Rust."),(0,i.kt)("li",{parentName:"ul"},"Internal errors (24 errors): Several internal errors occured."),(0,i.kt)("li",{parentName:"ul"},"Unexpected verification error (9 errors): Some verification failed."),(0,i.kt)("li",{parentName:"ul"},"Verification errors (14 errors): These seem to be the ones worth investigating.")),(0,i.kt)("h3",{id:"success"},"Success"),(0,i.kt)("p",null,"Prusti found potential overflow and underflow errors in the bitcoin crate:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// bitcoin/src/parser.rs\nif position + 4 > raw_bytes.len() {\n    return Err(Error::EndOfFile);\n}\n")),(0,i.kt)("p",null,"It also found possible issues with unbounded arrays:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// bitcoin/src/script.rs\npub fn op_return(return_content: &[u8]) -> Script {\n    let mut script = Script::new();\n    script.append(OpCode::OpReturn);\n    script.append(return_content.len() as u8);\n    script.append(return_content);\n    script\n}\n")),(0,i.kt)("h2",{id:"mirai"},"MIRAI"),(0,i.kt)("p",null,"From the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebookexperimental/MIRAI"},"developer's website"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"MIRAI is an abstract interpreter for the Rust compiler's mid-level intermediate representation (MIR). It is intended to become a widely used static analysis tool for Rust.")),(0,i.kt)("h3",{id:"getting-started-2"},"Getting started"),(0,i.kt)("p",null,"Installation of MIRAI was straightforward, following the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/facebookexperimental/MIRAI/blob/main/documentation/InstallationGuide.md"},"guide"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/facebookexperimental/MIRAI.git\ncd MIRAI\ncargo install --locked --path ./checker\n")),(0,i.kt)("p",null,"Next, I ran MIRAI in the interbtc root directory."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo mirai\n")),(0,i.kt)("h3",{id:"compilation-errors-1"},"Compilation Errors"),(0,i.kt)("p",null,"MIRAI produces compilation errors on the wasm builds:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'     Compiling wasm-test v1.0.0 (/tmp/.tmpfNz4QS)\n  error[E0463]: can\'t find crate for `std`\n    |\n    = note: the `wasm32-unknown-unknown` target may not be installed\n    = help: consider downloading the target with `rustup target add wasm32-unknown-unknown`\n    = help: consider building the standard library from source with `cargo build -Zbuild-std`\n\n  error: requires `sized` lang_item\n\n  For more information about this error, try `rustc --explain E0463`.\n  error: could not compile `wasm-test` due to 2 previous errors\n  warning: build failed, waiting for other jobs to finish...\n  error: cannot find macro `println` in this scope\n   --\x3e src/main.rs:3:5\n    |\n  3 |                 println!("{}", env!("RUSTC_VERSION"));\n    |                 ^^^^^^^\n\n  error: could not compile `wasm-test` due to 3 previous errors\n  ------------------------------------------------------------\n')),(0,i.kt)("h3",{id:"success-1"},"Success"),(0,i.kt)("p",null,"As the wasm build is done on the entire runtime, I decided to try my luck against a single pallet instead. Similar to before, I tried the fee crate. This worked and to my surprise, MIRAI did not print any warnings or errors."),(0,i.kt)("p",null,"Next, I tried the bitcoin create that implements parsing and other somewhat error prone code. MIRAI gave me results here:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"warning: possible attempt to subtract with overflow\n   --\x3e crates/bitcoin/src/parser.rs:239:24\n    |\n239 |     let target: U256 = parser.parse()?;\n    |                        ^^^^^^^^^^^^^^\n    |\nnote: related location\n   --\x3e crates/bitcoin/src/parser.rs:177:40\n    |\n177 |         let (result, bytes_consumed) = T::parse(&self.raw_bytes, self.position)?;\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: related location\n   --\x3e crates/bitcoin/src/parser.rs:151:23\n    |\n151 |         let compact = U256::set_compact(bits).ok_or(Error::InvalidCompact)?;\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^\nnote: related location\n   --\x3e crates/bitcoin/src/math.rs:53:25\n    |\n53  |             word << 8 * (size - 3)\n    |                         ^^^^^^^^^^\n")),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("p",null,"Overall, I was very happy with the results. I was able to run two tools against the crates without additional configuration and they found potential issues. Next up will be trying to implement custom verification rules and dive deeper into the identified issues."))}d.isMDXComponent=!0},7637:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/prusti-03fc7621aaa000baec571b5bb93e5210.png"}}]);