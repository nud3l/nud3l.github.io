"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"rust-verification","metadata":{"permalink":"/blog/rust-verification","editUrl":"https://github.com/nud3l/nud3l.github.io/blog/2023-02-20-rust-verification/index.md","source":"@site/blog/2023-02-20-rust-verification/index.md","title":"Verifying Rust: Exploring Verification Options for Substrate","description":"Security is hard to get right in blockchains. It\'s even harder to make sure that code is correct while still actively developing the product: code changes are frequent, requirements are changing, and the codebase is growing.","date":"2023-02-20T00:00:00.000Z","formattedDate":"February 20, 2023","tags":[{"label":"blockchain","permalink":"/blog/tags/blockchain"},{"label":"security","permalink":"/blog/tags/security"},{"label":"software-engineering","permalink":"/blog/tags/software-engineering"},{"label":"rust","permalink":"/blog/tags/rust"}],"readingTime":6.95,"hasTruncateMarker":false,"authors":[{"name":"Dominik Harz","title":"CTO Interlay","url":"https://harz.dev","imageURL":"https://github.com/nud3l.png","key":"dom"}],"frontMatter":{"slug":"rust-verification","title":"Verifying Rust: Exploring Verification Options for Substrate","tags":["blockchain","security","software-engineering","rust"],"authors":"dom"},"nextItem":{"title":"Lean Execution: How to Stay Focused","permalink":"/blog/lean-execution"}},"content":"Security is hard to get right in blockchains. It\'s even harder to make sure that code is correct while still actively developing the product: code changes are frequent, requirements are changing, and the codebase is growing.\\n\\nIn this post, we\'ll explore options for verifying blockchain code, specifically for the Substrate blockchain framework to try to verify the code of the [Interlay blockchain](https://www.github.com/interlay/interbtc). \\n\\nMy requirements for the test were simple: the tool should be integrated into the Rust toolchain (no DSLs) and I set myself a time limit of a single day to get started and get a useful result.\\n\\nSpoiler alert: I managed to get two tools running and produce output. This post covers only the setup and I will follow up with more details in a future post.\\n\\n## Substrate Runtimes as Verification Targets\\n\\nWe are building the [Interlay](https://interlay.io) and Kintsugi blockchains based on the Rust [Substrate](https://substrate.dev) framework.\\nFor verifying that the \\"code is correct\\", we are looking for two targets:\\n\\n1. **Runtime**: The WASM runtime encodes the rules of the blockchain subject to consensus verification. This is where we can potentially introduce logical errors in how the protocols are working or in their implementation such that we either impact the *safety* or *liveness* of the system.\\n2. **Node Implementation**: The node implementation wraps around the runtime. Bugs introduced here can impact the *liveness* of the system.\\n\\n## Diving into Verification\\n\\nSoftware verification is most often quite an academic exercise. With the adverse environment of blockchain development, there\'s a clear benefit of increased security assurance in the software development process.\\nThis goes hand in hand with the [desire of the verification community to integrate verification into the development process](https://alastairreid.github.io/papers/HATRA_20/).\\n\\nI\'ll not cover the usual testing and fuzzing tools but rather explore the three tools I found most accessible for verification in Rust.\\n\\nMy criteria for selecting tools were:\\n\\n1. **Actively maintained**: The tool should be actively maintained and have a community around it. I checked the GitHub repositories for current contributions and when the last commit was made.\\n2. **Clear documentation**: The tool should have clear documentation on how to use it and get started. If after 10 minutes of parsing the available documentation, I could not get a good understanding of how to install or use the tool, I would not use it.\\n3. **Rust integration**: Since the idea is to integrate the tool into the normal development workflow, I was looking for a tool that integrates well with `cargo` and also does not require writing verification code in a language other than Rust.\\n\\n## Selected Tools\\n\\nFrom the tools I found, I selected the following three tools for further exploration:\\n\\n- [kani](https://github.com/model-checking/kani)\\n- [Prusti](https://viperproject.github.io/prusti-dev/)\\n- [MIRAI](https://github.com/facebookexperimental/MIRAI)\\n\\nMore tools are available on the [Rust Formal Methods Interest Group](https://rust-formal-methods.github.io/tools.html) website and on [Alastair Reid\'s blog](https://alastairreid.github.io/automatic-rust-verification-tools-2021/).\\n\\nFor all tools, I installed them and ran them without any additional configuration against the [chain implementation](https://github.com/interlay/interbtc) of the Interlay blockchain.\\n\\n### A Note on Expectations\\n\\nI would be happy if a tool runs on the first try: installing the tool without issues and scanning the code base without setting up verification rules. Overall, the code is well-tested, but it is very complex: more than 1,000 dependencies, almost 100,000 lines of code, and invoking external C libraries.\\n\\n## kani\\n\\nFrom the [developer\'s website](https://model-checking.github.io/kani/getting-started.html):\\n\\n> Kani is an open-source verification tool that uses model checking to analyze Rust programs. Kani is particularly useful for verifying unsafe code in Rust, where many of the Rust\u2019s usual guarantees are no longer checked by the compiler.\\n\\n### Getting started\\n\\nI found getting started very easy with just two commands to execute:\\n\\n```bash\\ncargo install --locked kani-verifier\\ncargo kani setup\\n```\\n\\nNext, I ran kani against the runtime of the Interlay blockchain:\\n\\n```bash\\n# From the interbtc repo root\\ncargo kani\\n```\\n\\n### Compilation Errors\\n\\nThat produced the following error during the compilation of the `schnorrkel` crate:\\n\\n```bash\\nerror: format argument must be a string literal\\n   --\x3e /home/nud3l/.cargo/registry/src/github.com-1ecc6299db9ec823/schnorrkel-0.9.1/src/batch.rs:165:47\\n    |\\n165 |     assert!(hrams.len() == public_keys.len(), ASSERT_MESSAGE);\\n    |                                               ^^^^^^^^^^^^^^\\n    |\\nhelp: you might be missing a string literal to format with\\n    |\\n165 |     assert!(hrams.len() == public_keys.len(), \\"{}\\", ASSERT_MESSAGE);\\n    |                                               +++++\\n\\n```\\n\\nAt this point, I wasn\'t sure how to convince kani to ignore these errors in the dependencies. I tried running kani only on a single crate but it resulted in the same compiler issue.\\n\\nThe authors have a guide on how to get started with [real code](https://model-checking.github.io/kani/tutorial-real-code.html) but it does not include how to handle compiler errors in dependencies.\\n\\n## Prusti\\n\\nFrom the [developer\'s website](https://viperproject.github.io/prusti-dev/):\\n\\n> Prusti is a verification tool for Rust programs. It is based on the Rust compiler and uses the Rust type system to verify Rust programs. Prusti is a research prototype and is not yet ready for production use.\\n\\n### Getting started\\n\\nGetting started with Prusti required downloading the Prusti Assistant VS Code extension.\\nI already had the required Java SDk and `rustup` versions installed so the process of getting started only involved opening a rust file and hitting the \\"Verify with Prusti\\" button on the VS Code status bar.\\n\\n![Prusti](prusti.png)\\n\\nAs the first target, the [fee pallet](https://github.com/interlay/interbtc/blob/master/crates/fee/src/lib.rs) seemed interesting as it\'s mildly complex, has few dependencies, and with its fixed point math might be subject to issues.\\n\\n### Errors\\n\\nOn the first run on the fee crate, Prusti found 358 errors. That seemed quite a lot but after initial inspection, most of the errors were:\\n\\n- Unsupported features (313 errors): I was expecting Prusti with its [current feature set](https://viperproject.github.io/prusti-dev/user-guide/verify/summary.html) to run into these issues as substrate makes heavy use of macros, traits, and other advanced features of Rust.\\n- Internal errors (24 errors): Several internal errors occured.\\n- Unexpected verification error (9 errors): Some verification failed.\\n- Verification errors (14 errors): These seem to be the ones worth investigating.\\n\\n### Success\\n\\nPrusti found potential overflow and underflow errors in the bitcoin crate:\\n\\n```rust\\n// bitcoin/src/parser.rs\\nif position + 4 > raw_bytes.len() {\\n    return Err(Error::EndOfFile);\\n}\\n```\\n\\nIt also found possible issues with unbounded arrays:\\n\\n```rust\\n// bitcoin/src/script.rs\\npub fn op_return(return_content: &[u8]) -> Script {\\n    let mut script = Script::new();\\n    script.append(OpCode::OpReturn);\\n    script.append(return_content.len() as u8);\\n    script.append(return_content);\\n    script\\n}\\n```\\n\\n## MIRAI\\n\\nFrom the [developer\'s website](https://github.com/facebookexperimental/MIRAI):\\n\\n> MIRAI is an abstract interpreter for the Rust compiler\'s mid-level intermediate representation (MIR). It is intended to become a widely used static analysis tool for Rust.\\n\\n### Getting started\\n\\nInstallation of MIRAI was straightforward, following the [guide](https://github.com/facebookexperimental/MIRAI/blob/main/documentation/InstallationGuide.md):\\n\\n```bash\\ngit clone https://github.com/facebookexperimental/MIRAI.git\\ncd MIRAI\\ncargo install --locked --path ./checker\\n```\\n\\nNext, I ran MIRAI in the interbtc root directory.\\n\\n```bash\\ncargo mirai\\n```\\n\\n### Compilation Errors\\n\\nMIRAI produces compilation errors on the wasm builds:\\n\\n```bash\\n     Compiling wasm-test v1.0.0 (/tmp/.tmpfNz4QS)\\n  error[E0463]: can\'t find crate for `std`\\n    |\\n    = note: the `wasm32-unknown-unknown` target may not be installed\\n    = help: consider downloading the target with `rustup target add wasm32-unknown-unknown`\\n    = help: consider building the standard library from source with `cargo build -Zbuild-std`\\n\\n  error: requires `sized` lang_item\\n\\n  For more information about this error, try `rustc --explain E0463`.\\n  error: could not compile `wasm-test` due to 2 previous errors\\n  warning: build failed, waiting for other jobs to finish...\\n  error: cannot find macro `println` in this scope\\n   --\x3e src/main.rs:3:5\\n    |\\n  3 |                 println!(\\"{}\\", env!(\\"RUSTC_VERSION\\"));\\n    |                 ^^^^^^^\\n\\n  error: could not compile `wasm-test` due to 3 previous errors\\n  ------------------------------------------------------------\\n```\\n\\n### Success\\n\\nAs the wasm build is done on the entire runtime, I decided to try my luck against a single pallet instead. Similar to before, I tried the fee crate. This worked and to my surprise, MIRAI did not print any warnings or errors.\\n\\nNext, I tried the bitcoin create that implements parsing and other somewhat error prone code. MIRAI gave me results here:\\n\\n```bash\\nwarning: possible attempt to subtract with overflow\\n   --\x3e crates/bitcoin/src/parser.rs:239:24\\n    |\\n239 |     let target: U256 = parser.parse()?;\\n    |                        ^^^^^^^^^^^^^^\\n    |\\nnote: related location\\n   --\x3e crates/bitcoin/src/parser.rs:177:40\\n    |\\n177 |         let (result, bytes_consumed) = T::parse(&self.raw_bytes, self.position)?;\\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\nnote: related location\\n   --\x3e crates/bitcoin/src/parser.rs:151:23\\n    |\\n151 |         let compact = U256::set_compact(bits).ok_or(Error::InvalidCompact)?;\\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^\\nnote: related location\\n   --\x3e crates/bitcoin/src/math.rs:53:25\\n    |\\n53  |             word << 8 * (size - 3)\\n    |                         ^^^^^^^^^^\\n```\\n\\n## Summary\\n\\nOverall, I was very happy with the results. I was able to run two tools against the crates without additional configuration and they found potential issues. Next up will be trying to implement custom verification rules and dive deeper into the identified issues."},{"id":"lean-execution","metadata":{"permalink":"/blog/lean-execution","editUrl":"https://github.com/nud3l/nud3l.github.io/blog/2022-02-21-lean-execution.md","source":"@site/blog/2022-02-21-lean-execution.md","title":"Lean Execution: How to Stay Focused","description":"When building a company and shipping a product, it\'s both critical and extremely hard to stay focused.","date":"2022-02-21T00:00:00.000Z","formattedDate":"February 21, 2022","tags":[{"label":"agile","permalink":"/blog/tags/agile"},{"label":"lean","permalink":"/blog/tags/lean"},{"label":"execution","permalink":"/blog/tags/execution"},{"label":"startup","permalink":"/blog/tags/startup"},{"label":"product","permalink":"/blog/tags/product"},{"label":"engineering","permalink":"/blog/tags/engineering"}],"readingTime":3.255,"hasTruncateMarker":false,"authors":[{"name":"Dominik Harz","title":"CTO Interlay","url":"https://harz.dev","imageURL":"https://github.com/nud3l.png","key":"dom"}],"frontMatter":{"slug":"lean-execution","title":"Lean Execution: How to Stay Focused","tags":["agile","lean","execution","startup","product","engineering"],"authors":"dom"},"prevItem":{"title":"Verifying Rust: Exploring Verification Options for Substrate","permalink":"/blog/rust-verification"},"nextItem":{"title":"Stealing All of Maker\'s Collateral","permalink":"/blog/maker-collateral-attack"}},"content":"When building a company and shipping a product, it\'s both critical and extremely hard to stay focused.\\nMuch has been written about this subject before.\\nI\'m sharing here which three questions I\'m trying to ask myself to help to stay lean.\\n\\n# Why do we need this feature?\\n\\nMost of the time, you or a colleague got a great idea to improve the product or the company.\\nEspecially, when you have not found product-market fit yet or the company is growing, you might feel the urge to add things, change things, and generally make sure you are set up for success.\\nHowever, I find myself often in discussions bout how to implement said change/feature instead of why?\\nBefore going into the actual implementation, I try to understand two critical aspects:\\n\\n- What benefit does this change bring to our users? This can be the users of our product, users of internal or external processes, or anyone that stands to benefit from this change. It\'s helpful to classify the using T-shirt sizes from S to XL and later go into a more concrete assessment (what % of our user base profits from this, are these the critical users, ...).\\n- Does this support our company goals in the mid/long-term? Sometimes a new feature can be beneficial to a user, but might not be in the long-term strategical interest of the company. I like to also use the T-shirt sizes here to gauge this question and later analyze this in more detail.\\n\\n\\n# When do we need this feature?\\n\\nBefore talking about how to implement a feature, it\'s critical to understand where it fits in the roadmap.\\nIf you anyway decided that the feature does not add any benefit (see question 1), it\'s likely not worthwhile to specify a concrete timeline but rather give it some sort of medium or low priority on the backlog.\\nHowever, if it\'s an important feature, the next step is to understand the dependencies of where it fits in the roadmap.\\n\\nSome key questions I like to think about:\\n\\n- Does the feature require another feature to be launched first to make it useful? Understand if there is a required sequence of steps.\\n- Can we launch without the feature? Is the feature critical and we cannot ship to the user without it. Or would it be great to have at launch but not critical.\\n\\n# How should we launch the feature?\\n\\nAfter understanding the added value of the feature and its order in the timeline, the next step is to understand how the feature should be launched.\\nSometimes this process is overlooked but I find it helpful to acknowlegdge that you can and often should simplify features to their core value proposition.\\nIn crypto, the first iteration of Uniswap was simple but it worked.\\nMakerDAO launched with a single collateral asset and it worked as well.\\nIdentifying the critical feature set is a hard exercise and requires an excellent understanding of user demand and competitor position.\\n\\nI\'m an engineer and researcher at heart and we tend to often strive for a perfect, over-engineered solution that covers every edge case.\\nIt\'s even worse coming from a security-focused background where your first step is to ask: How do we break this protocol?\\n\\nIn the product world, I found it often acceptable to tolerate limited sub-optimal edge cases in the product, acknowledge them, and fix them later.\\nThe point here is that you want to get a product out at the right time.\\nAnd more often than not, getting the feature out with its essential benefit and have it \\"good enough\\" saves significant effort.\\n\\nThis last point I find often overlooked. Additional complexity in the feature costs us often 3x more time investment down the line since it\'s not just the design that is more complicated. It\'s also the implementation, the documentation, and the testing that are proportionally more involved."},{"id":"maker-collateral-attack","metadata":{"permalink":"/blog/maker-collateral-attack","editUrl":"https://github.com/nud3l/nud3l.github.io/blog/2020-02-20-maker/index.md","source":"@site/blog/2020-02-20-maker/index.md","title":"Stealing All of Maker\'s Collateral","description":"Or why Oracle Vulnerabilities are not the Worst Application of Flash Loans.","date":"2020-02-20T00:00:00.000Z","formattedDate":"February 20, 2020","tags":[{"label":"DeFi","permalink":"/blog/tags/de-fi"},{"label":"MakerDAO","permalink":"/blog/tags/maker-dao"},{"label":"Security","permalink":"/blog/tags/security"},{"label":"Flashloans","permalink":"/blog/tags/flashloans"}],"readingTime":8.14,"hasTruncateMarker":false,"authors":[{"name":"Dominik Harz","title":"CTO Interlay","url":"https://harz.dev","imageURL":"https://github.com/nud3l.png","key":"dom"}],"frontMatter":{"slug":"maker-collateral-attack","title":"Stealing All of Maker\'s Collateral","tags":["DeFi","MakerDAO","Security","Flashloans"],"authors":"dom"},"prevItem":{"title":"Lean Execution: How to Stay Focused","permalink":"/blog/lean-execution"},"nextItem":{"title":"Analysing Ethereum contract gas costs during development","permalink":"/blog/analysing-ethereum-gas-cost"}},"content":"Or why Oracle Vulnerabilities are not the Worst Application of Flash Loans.\\n\\n## tl;dr\\n\\n- You can potentially steal all of Maker\u2019s collateral ($700m) and issue arbitrary amounts of new Dai using flash loans if no delay for new governance contracts is introduced.\\n- Anyone can execute the attack and only needs to pay the transaction fees (few $) without holding any MKR.\\n- If Maker does not introduce a delay until the liquidity pools for flash loan pools gets above a threshold, there is little chance to prevent the attack (race condition).\\n- We have reached out to Maker February 8, 2020 about our research and had a call with them on February 14, 2020 to discuss our findings. Maker is aware of the attack vector [and is holding a vote this Friday 12pm PST that would prevent the attack](https://forum.makerdao.com/t/all-mkr-holders-on-friday-12pm-pst-please-vote-for-the-gsm-to-be-activated/1303).\\n\\n## Introduction\\n\\nMaker and its Dai stablecoin is the most popular so-called decentralized finance (DeFi) project on Ethereum with around of $700m locked in its smart contracts. The Maker protocol relies on a governance process encoded in a smart contract. MKR token holders can vote to replace an existing governance contract. Votes are proportional to the amount of MKR. The total number of MKR tokens is around 987,530 [where selected wallets or contracts hold large quantities of the token](https://etherscan.io/token/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2#balances):\\n\\n- [Maker Governance Contract: 192,910 MKR]\\n- Maker Foundation: 117,993 MKR\\n- a16z: 60,000 MKR\\n- 0xfc7e22c6afa3ebb723bdde26d6ab3783aab9726b: 51,291 MKR\\n- 0x000be27f560fef0253cac4da8411611184356549: 39,645 MKR\\n\\nNote: the Maker Governance Contract contains MKR tokens of multiple parties.\\n\\n## Governance Attack\\n\\nIn a [post from December 2019, Micah Zoltu](https://medium.com/coinmonks/how-to-turn-20m-into-340m-in-15-seconds-48d161a42311) pointed out how to attack the Maker governance contract. The basic idea is to accumulate enough MKR tokens to replace the existing governance contract with the attackers, malicious, governance contract. The malicious governance contract is then able to give the attacker full control over the system and withdraw any collateral in the system as well as create arbitrary amounts of new Dai.\\n\\nTo reduce the number of required MKR tokens, he proposed to execute the attack when new governance contracts are being voted on. At the moment, 192,910 MKR tokens are locked in the governance contract. However, an attacker would need less tokens if, say two or three contracts, would be voted on in parallel with similar token distributions. This frequently happened in the past as we can observe in the graph below:\\n\\n![](mkr_locked.webp)\\n\\nThe obvious attack strategy would be to crowd-fund the required MKR tokens through a smart contract and pay each attacker a share of the of the winnings. However, the attackers need to amass probably around 50k MKR tokens to have a chance to attack the system without Maker noticing these movements. We do show a strategy for this in our [latest paper](https://arxiv.org/abs/2002.08099).\\n\\n## A Brave New Attack Strategy: Flash Loans\\n\\nHowever, we can completely lift the requirement to amass MKR tokens if we consider using flash loans instead. Flash loans are a fairly new concept and therefore we give a brief explanation here. Normally, an agent has to provide collateral to take out a loan in the DeFi space. For example, in Maker, Alice can borrow Dai by depositing ETH. This is required since we operate under a model of [weak identities](https://bdlt.school/files/slides/talk-rainer-b%C3%B6hme-a-primer-on-economics-for-cryptocurrencies.pdf) and [economically rational agents](https://eprint.iacr.org/2019/675).\\n\\nA flash loan lifts this requirement as it only takes place in a single transaction:\\n\\n1. Alice takes out the loan from a flash loan liquidity provider (e.g. Aave or dYdX)\\n2. Alice executes some actions (e.g. arbitrage trading on Uniswap, Fulcrum, Kyber etc.)\\n3. Alice pays back the flash loan with interest\\n\\nA flash loan works in three steps within a single transaction.\\n\\n![](flash-loan.webp)\\n\\nThe flash loan works because of how the Ethereum Virtual Machine is designed: if at any point during this transaction the flash loan fails, the whole transaction is reverted. Hence, Alice can take the loan risk free, i.e. if she cannot pay it back it would be like she would have never taken it. The liquidity providers are also winning: they have only lent their funds if Alice was able to pay them back.\\n\\n## Arbitrage and Oracle Manipulation with Flash Loans\\n\\nOn February 14 and February 18, two incidents involving flash loans occurred that caused [bZx](https://bzx.network/) to halt its platform. In the [first transaction](https://etherscan.io/tx/0xb5c8bd9430b6cc87a0e2fe110ece6bf527fa4f170a4bc8cd032f768fc5219838), a single flash loan was able to make a profit of 1,193 ETH (approx. $298,250). This transaction was executed using a smart contract that opened a short position on Fulcrum on wBTC. In the same transaction, the transaction took out a wBTC loan on Compound and executed a trade of wBTC on Kyber\u2019s Uniswap reserve resulting in slippage ultimately bringing down the price on Fulcrum as well. The full details can be found in the [post-mortem by bZx](https://bzx.network/blog/postmortem-ethdenver) and a [detailed analysis of the involved calls by PeckShield](https://medium.com/@peckshield/bzx-hack-full-disclosure-with-detailed-profit-analysis-e6b1fa9b18fc).\\n\\nSimilarly, a second incident occurred on February 18 where in a [single transaction](https://etherscan.io/tx/0x762881b07feb63c436dee38edd4ff1f7a74c33091e534af56c9f7d49b5ecac15) a profit of 2,378 ETH (approx. $600,000) was made. This transaction involved an initial borrowing of 7,500 ETH to take a long position on [Synthetix\'](https://www.synthetix.io/tokens/) sUSD. More details are found in this [informal analysis](https://twitter.com/DegenSpartan/status/1229646531717820416?s=20).\\n\\n## Oracle Manipulation to Reduce Required Liquidity\\n\\nFor our attack, we assume that 50k MKR are sufficient. Even if in practice the number of tokens could be higher, we point out how the concept of flash loans makes securing Maker, without a governance delay, hard. In a naive approach, the attacker could take out a flash loan to buy 50k MKR tokens.\\n\\nAt current exchange rates, the attacker [needs around 485,000 ETH to buy that amount of MKR as only a single exchange](https://dexindex.io/?symbol=MKR&amount=50000&action=buy), Kyber, has enough volume available. However, the attacker can also leverage multiple exchanges and buy 38k MKR from Kyber, 11.5k from Uniswap, and 500 MKR from Switcheo for a total of 378,940 ETH. That number is still high but already a reduction by almost 100,000 ETH!\\n\\nAn attacker can use the oracle manipulation strategies above to effectively bring down the price of MKR on Kyber and Uniswap. These are the two largest providers of MKR and have shown to be vulnerable to oracle price manipulation. Further analysis is required to determine how much the MKR price can be reduced. However, on a less liquid token like wBTC an [attacker was able manipulate the exchange rate by around 285%](https://medium.com/@peckshield/bzx-hack-full-disclosure-with-detailed-profit-analysis-e6b1fa9b18fc).\\n\\n\\n## Obtaining enough Liquidity\\n\\n![eth-locked.webp](eth-locked.webp)\\n\\nEven with oracle manipulation, a large number of ETH is required to execute the attack on Maker. However, an attacker can increase its liquidity by taking out two flash loans within the same transaction. Aave and dYdX protect themselves against reentrancy and allow only a single flash loan within a single transaction. But the attacker can borrow ETH from both protocols within the same transaction.\\n\\n![](eth-locked-dydx.webp)\\n\\nThus, as of February 18, the attacker has a pool of around [90k ETH on dYdX](https://trade.dydx.exchange/markets) plus [17k ETH on Aave](https://app.aave.com/borrow/ETH) available. Hence, at current liquidity rates an attacker could take out a combined ~107k ETH loan from both dYdX and Aave to try to manipulate the MKR token price and obtain enough MKR tokens to replace the current Maker governance contract with its own.\\n\\nFor this to succeed the attacker must be able to reduce average MKR price by at least 3.54 times. Alternatively, the attacker can also wait for dYdX and Aave to increase its liquidity pools. With the current growth rate of around 5% of both protocols, it does not seem unlikely that the attack becomes possible within two months.\\n\\n## Combination?\\n\\nObviously, it is possible to combine the crowd funding approach and the flash loan together. Using the available liquidity of ~107k ETH, it is possible to obtain around 10,800 MKR from Kyber. This would allow multiple attackers to reduce the required amount of pooling together 50k MKR to just around 39.2k MKR. It seems also that some people are indeed interested in such an attack as this informal Twitter poll shows:\\n\\n![](twitter.webp)\\n\\n[It can also be noted that the top four account holders](https://etherscan.io/token/0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2#balances) (in fact five, but not considering the current Maker Governance Contract) are able to execute the attack without crowdfunding.\\n\\n## No Time to Wait\\n\\nOnce enough liquidity is available through the flash loan lending pools (with or without the combination of using oracle manipulation), anyone is able to take over the Maker governance contract. Once Maker starts a vote when the liquidity pools have reached that threshold, Maker needs to ensure that MKR tokens are as little distributed as possible. If the distribution of MKR at any point in this voting procedure allows for an exploit of the vulnerability, any collateral can be taken away.\\n\\nThat attacker would be able to steal $700m worth of ETH collateral and be able to print new Dai at will. This attack would spread throughout the whole DeFi space as Dai is used as backing collateral in other protocols. Further, the attacker can use his Dai to trade other currencies worth around $230m. [We give a more detailed analysis in our paper.](https://arxiv.org/abs/2002.08099)\\n\\n## Counter measure\\n\\nMaker should put a new governance contract in place that prevents flash loans from attacking their system. Specifically, a new governance contract should be able to be checked by the Maker Foundation for malicious code and give enough time to react. At the bare minimum, a new governance contract should not be able to go live within a single transaction. That way, the attacker can likely not profit from the attack and thus not repay the flash loan.\\nIf the attacker cannot repay the flash loan, the attack is like it would have never happened.\\n\\nMaker is putting such a contract to vote on Friday, 12pm PST, February 21, 2020. [The proposed contract would activate the Governance Security Module (GSM) and prevent such a flash loan attack.](https://forum.makerdao.com/t/all-mkr-holders-on-friday-12pm-pst-please-vote-for-the-gsm-to-be-activated/1303/2)"},{"id":"analysing-ethereum-gas-cost","metadata":{"permalink":"/blog/analysing-ethereum-gas-cost","editUrl":"https://github.com/nud3l/nud3l.github.io/blog/2018-11-06-analysing-ethereum-gas-cost.md","source":"@site/blog/2018-11-06-analysing-ethereum-gas-cost.md","title":"Analysing Ethereum contract gas costs during development","description":"Updating the state of a smart contract in Ethereum costs money. In this post I will go a bit into detail why this is necessary in Ethereum and how to check easily (with truffle test) your gas costs during local development. For this we will use a little pet example, you can use for your own deployments.","date":"2018-11-06T00:00:00.000Z","formattedDate":"November 6, 2018","tags":[],"readingTime":4.735,"hasTruncateMarker":false,"authors":[{"name":"Dominik Harz","title":"CTO Interlay","url":"https://harz.dev","imageURL":"https://github.com/nud3l.png","key":"dom"}],"frontMatter":{"slug":"analysing-ethereum-gas-cost","title":"Analysing Ethereum contract gas costs during development","categories":["blockchain","ethereum","smart-contracts","gas","truffle","testing"],"authors":"dom"},"prevItem":{"title":"Stealing All of Maker\'s Collateral","permalink":"/blog/maker-collateral-attack"},"nextItem":{"title":"Analyzing Bitcoin smart contracts from a mechanism design perspective","permalink":"/blog/bitcoin-smart-contracts-mechanism-design"}},"content":"Updating the state of a smart contract in Ethereum costs money. In this post I will go a bit into detail why this is necessary in Ethereum and how to check easily (with `truffle test`) your gas costs during local development. For this we will use a little pet example, you can use for your own deployments.\\n\\n## Gas cost - why?\\nEthereum smart contracts are deployed at an address in the Ethereum network. They are identifiable by the fact that the `code` field in the address is occupied by the EVM bytecode. One example is the Maker [Dai contract](https://etherscan.io/address/0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359#code). Any contract in Ethereum is deployed that way and implements a range of functions that can update its own state and the state of the blockchain.\\n\\nThe own state is defined within the contract and refers to any contract wide variables you define like `uint`, `mapping`, or `string`. The global state of the network is affected when you make a transaction to a contract, which, if everything goes right, will include one more transaction in the ever-growing list of transactions.\\n\\nEverytime somebody invokes a state update (i.e. sends a transaction), the network reaches consensus over this operation. If 50% + 1 decide that the state transition is valid, the network state gets updated. However, this means that if you have a function that does `5 + 4` and stores the result to a contract variable, every node in the network need to verify that the result is in fact `9`. Assuming that Ethereum has [more than 12,000 nodes](https://www.ethernodes.org/network/1), this is quite costly.\\n\\nMoreover, assume that any of these operations are free. One could simply create a function that runs indefinitely to block all nodes verifying the network. This is the equivalent to a distributed denial-of-service attack. It would be nice if we would know in advance if a function terminates. However, the [Halting problem](https://en.wikipedia.org/wiki/Halting_problem) prevents us from knowing this. Hence, we have to charge partial function execution and forcefully terminate execution when it becomes to burdensome for the network.\\n\\n## Practical implications\\nOperations executed by the EVM cost gas depending how \\"heavy\\" they are on the network. Gas is a way of determining the cost for an operation. The current gas price on the other hand determines how much 1 gas costs in Ether. That way, the gas cost can be adjusted depending on the network load. For example, while the gas cost for a single operation is constant, the gas price can go up when the network is congested. An overview [of the gas costs are found in appendix G of the yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf).\\n\\n## Local execution and global execution\\nAny operation on a smart contract costs gas. It is important to note a difference though. **Calls** are only executed locally. So for example the function below measures its gas, but the you will not be charged executing such a function as it is a read-only function.\\n\\n```\\nfunction balanceOf(address owner) public view returns (uint256) {\\n    return _balances[owner];\\n}\\n```\\n\\nHowever, **transactions** will deduct Ether from your balance as those are executed by the global network and miners need to have an incentive to include your transaction in a block. So the function below is from an ERC20 and executes a transfer. This updates the contract state, and thus requires a transaction.\\n\\n```\\nfunction _transfer(address from, address to, uint256 value) internal {\\n    require(value <= _balances[from]);\\n    require(to != address(0));\\n\\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n    emit Transfer(from, to, value);\\n}\\n```\\n\\n## Measuring gas costs\\nI will assume here that you are familiar with [Truffle](https://truffleframework.com/docs) and [Ganache](https://truffleframework.com/docs/ganache/overview). When you develop your new great smart contracts, I like to create end-to-end tests that also check for gas costs.\\n\\nAssuming your project folder looks something like this:\\n```\\ncontracts/\\nmigrations/\\ntest/\\n```\\n\\nI am creating a folder `mkdir experiments` where I will store the number of transactions each of my interactions require and the amount of gas that this operation is using.\\n\\nNext, I\'m creating a test script `demo.js` in the test folder. I like to store my experiments in a CSV format so I can import it to other tools. First, the required imports:\\n\\n```\\nvar fs = require(\\"fs\\");\\nvar csvWriter = require(\'csv-write-stream\');\\nvar writer = csvWriter();\\n\\n// your contract\\nconst ERC20 = artifacts.require(\\"./ERC20.sol\\");\\n```\\n\\nYou will write your tests based on the Truffle/Mocha/Chai interface. For this, I\'m creating the variables I am using to store the measurements.\\nAlso, I am using the `before` construct to setup the CSV writer. During tests I would update the gas and number of transaction related counters.\\n\\nAfter the tests are finished, the data is written to a CSV file. To USD conversion uses a helper function.\\n\\n```\\ncontract(\'ERC20\', async (accounts) => {\\n    // gas price conversion\\n    const gas_limit = 7988288;\\n\\n    // experiment related vars\\n    var transfer_success_gas = 0;\\n    var transfer_fail_gas = 0;\\n    var transfer_success_tx = 0;\\n    var transfer_fail_tx = 0;\\n\\n    // any other const or vars\\n    // ...\\n\\n    before(\'Create writer for experiments\', async () => {\\n        writer.pipe(fs.createWriteStream((\'./experiments/ERC20.csv\')));\\n    })\\n\\n    after(\'Write experiment data to file\', async () => {\\n        let transfer_success_usd = convertToUsd(transfer_success_gas);\\n        let transfer_fail_usd = convertToUsd(transfer_fail_gas);\\n\\n        writer.write(\\n                {\\n                    Transfer: transfer_success_gas,\\n                    TransferFail: transfer_fail_gas,\\n                });\\n        writer.write(\\n            {\\n                Transfer: transfer_success_usd,\\n                TransferFail: transfer_fail_usd,\\n            });\\n        writer.write(\\n            {\\n                Transfer: transfer_success_tx,\\n                TransferFail: transfer_fail_tx,\\n            });\\n        writer.end();\\n    })\\n\\n    // your tests\\n    // it(\\"Transfer Success\\")\\n    // it(\\"Transfer Fail\\")\\n})\\n```\\n\\nThe USD conversion function works like this. I have this in a separate file called `helpers.js` that I export/import as a module.\\n\\n```\\nconvertToUsd: function (gasCost) {\\n    // gas price conversion\\n    const gas_price = web3.toWei(5, \\"gwei\\");\\n    const eth_usd = 200; // USD\\n\\n    return gasCost * web3.fromWei(gas_price, \\"ether\\") * eth_usd;\\n}\\n```\\n\\nThat\'s it. You can run the experiment with `truffle test path/to/the/file.js`."},{"id":"bitcoin-smart-contracts-mechanism-design","metadata":{"permalink":"/blog/bitcoin-smart-contracts-mechanism-design","editUrl":"https://github.com/nud3l/nud3l.github.io/blog/2018-09-12-mechanism-design.md","source":"@site/blog/2018-09-12-mechanism-design.md","title":"Analyzing Bitcoin smart contracts from a mechanism design perspective","description":"Contracts can be used to enforce agreements between entities.","date":"2018-09-12T00:00:00.000Z","formattedDate":"September 12, 2018","tags":[{"label":"blockchain","permalink":"/blog/tags/blockchain"},{"label":"DeFi","permalink":"/blog/tags/de-fi"},{"label":"mechanism design","permalink":"/blog/tags/mechanism-design"},{"label":"smart contracts","permalink":"/blog/tags/smart-contracts"},{"label":"Bitcoin","permalink":"/blog/tags/bitcoin"}],"readingTime":10.97,"hasTruncateMarker":false,"authors":[{"name":"Dominik Harz","title":"CTO Interlay","url":"https://harz.dev","imageURL":"https://github.com/nud3l.png","key":"dom"}],"frontMatter":{"slug":"bitcoin-smart-contracts-mechanism-design","title":"Analyzing Bitcoin smart contracts from a mechanism design perspective","tags":["blockchain","DeFi","mechanism design","smart contracts","Bitcoin"],"authors":"dom"},"prevItem":{"title":"Analysing Ethereum contract gas costs during development","permalink":"/blog/analysing-ethereum-gas-cost"},"nextItem":{"title":"Integrating Python and Ethereum","permalink":"/blog/ethereum-python-integration"}},"content":"Contracts can be used to enforce agreements between entities.\\nTo this extent, smart contracts have been proposed by Nick Szabo and implemented for example in Bitcoin.\\nThis article covers the basics of mechanism design of smart contracts in the context of Bitcoin.\\nMechanism design is concerned with creating or encoding preferences in an agreement.\\nHence, an author of a smart contract can create a mechanism that enforces certain behaviour of the agents (or humans) interacting with the contract.\\nEssentially, the author of the contract wants to reward desired behaviours and punish undesired behaviours.\\nThis is widely used in cryptocurrency protocols including the Lightning Network or Ethereum-based protocols such as Casper or TrueBit.\\n\\n**Use Case:** Agents having access to sensors could sell the sensor data they are collecting to agents willing to buy this data.\\nThis represents a simple contract where a resource is exchanged for a price.\\nBitcoin in combination with payment channels secure the payments and allow for micro-payments.\\nThus, one has to design protocols integrating with these existing technologies to achieve for example secure decentralised data exchanges.\\n\\n\\n## Bitcoin and smart contracts\\n\\nNakamoto introduced Bitcoin as a way to send money between peers without trusted third parties \\\\[2\\\\].\\nIn Nakamoto consensus the heaviest chain is considered having correct transactions as most miners have contributed to this specific chain by solving a proof of work (PoW) puzzle.\\nAssuming that the majority of players in the system are honest (i.e.\xa0$50\\\\% + 1$), the heaviest chain represents the \\"true\\" state of the network.\\n\\nBitcoin also included the capability of executing smart contracts with Bitcoin Script \\\\[3\\\\].\\nA smart contract is a piece of software which formalises a relationship between entities much like a legal contract\xa0\\\\[4\\\\].\\nHowever, the idea is to use secure computer protocols and include game theoretic elements to cover aspects that cannot be adequately verified in the protocol.\\nSzabo argues that smart contracts cover interactions including search, negotiation, commitment, performance, and adjudication.\\n\\n## Rational agents\\n\\nAgents in decentralised systems are self-interested \\\\[5\\\\].\\nHence, protocols facilitating (economic) interactions between agents need to account for autonomous agents to behave rationally.\\nA set of agents $P = \\\\{1 ... n\\\\}$ is considered to be rational if they seek maximise their utility $u_i$ depending on some function \\\\[5\\\\] \\\\[6\\\\] \\\\[1\\\\].\\nThis is especially relevant in decentralised systems, where we have to assume agents act only in their interest.\\nAgents can apply multiple strategies $s \\\\in S$ within a negotiation \\\\[1\\\\].\\nWe have to assume that agents will execute actions $\\\\theta \\\\in \\\\Theta$ based on $s$ that optimises their utility including cheating, lying, breaking contracts, and hiding their intentions.\\nHowever, we also assume that agents that interact can find an outcome $\\\\omega \\\\in \\\\Omega$ that increases or optimises $u_i$.\\n\\n## Mechanism design\\n\\nMechanism design is used to encode preferences in an agreement.\\nEssentially, a \\"designer\\" defines a preferred social choice which, under the assumption of rational agents, the mechanism is intended to favour \\\\[6\\\\].\\nConsidering a contract $C$ as an agreement between agents, $C$ implements a mechanism $M = (\\\\Sigma, g)$ \\\\[7\\\\].\\nThe outcome of the mechanism $g$ depends on the actions of agents $\\\\Sigma$.\\n$M$ implements a rule $f$.\\nRational agents would only enter $C$ or follow $C$ if $f$ is the result of the dominant strategies or Nash equilibrium of the agents.\\n\\nAn agent will have multiple options to enter contracts with other agents.\\nTo ensure that the proposed contract $C$ is chosen, we want to have it incentive compatible.\\nLoosely speaking incentive compatibility of a mechanism occurs when the utility $u_i$ of each agent $i$ is maximised when an agent is \\"truth-telling\\" (i.e.\xa0the dominant strategy).\\nIn games without money, non-trivial choices (e.g.\xa0more than two contracts, multiple potential agents, multiple different terms) lead either to incentive incompatibility, or the social choice function is a dictatorship according to the Gibbard--Satterthwaite theorem.\\nHowever, in Bitcoin, we can construct games with money.\\n\\n## Games in Bitcoin\\n\\nIn games with money, a Vickery-Clarke-Groves (VCG) mechanism maximises social welfare.\\nA VCG mechanism is incentive compatible. Hence an agent strives to implement a contract as such a mechanism.\\nTo construct such games the mechanism the Clarke pivot rule can be applied \\\\[6\\\\].\\nAgents in Bitcoin are playing a game with strict incomplete information.\\nOne could argue that an agent could potentially analyse actions of an agent as transactions are public.\\nHowever, as agents might take multiple identities (Sybil), this is a non-trivial task, and thus, we will not consider it in this case.\\nWe further assume that agents have independent private values, i.e.\xa0resources subject to trade do not depend on the other agents.\\n\\nSuch a game can be defined as follows \\\\[6\\\\]:\\n\\n- A set of players $P = \\\\{1, .., n\\\\}$ exists.\\n- Every player $i$ has a set of actions $\\\\Sigma_i$.\\n- Every player $i$ has a set of types $T_i$. A value $t_i \\\\in T_i$ is a private input to the player.\\n- Every player $i$ has a utility function $u_i$. The utility function depends on its private input and the actions of all players $u_i = (t_i, \\\\sigma_1, .., \\\\sigma_n)$.\\n\\nHence, a player must choose an action only based on his private input but without knowing the private inputs of other agents.\\nA strategy $s$ describes an agent\'s decision to execute a specific action based on a private input.\\nThe agent will choose $s$ that is the best response to any $\\\\sigma$ by other agents.\\n\\nHowever, an agent needs to optimise a specific social choice.\\nIn Bitcoin, we are not concerned with social welfare as a social choice as this is unknown to the agents and they are not naturally interested in the utility of others.\\nIn the case that only two agents are involved and we have a simple contract concerning one resource, single-parameter domains can be applied \\\\[6\\\\].\\nIn such domains, the valuation $v_i$ of an agent depends only on one parameter, say obtaining the resource.\\nMoreover, the price an agent is willing to pay is already included in the incentive mechanism.\\n\\nYet, this would only hold for the case where two agents compete for obtaining a single resource.\\nIn more complex cases, for example, adding the quality of the data, we need to apply a more complex social choice function.\\nIn these cases, variations of VCG are the only incentive compatible mechanisms \\\\[6\\\\].\\n\\n## Assumptions\\n\\nUsing the resource exchange formalisation described in \\\\[1\\\\] the following tuple defines the exchange setting:\\n\\n$$(P,\\\\mathcal{Z}, (v_{i})_{i \\\\in P})$$\\n\\nWe are assuming that two agents exist, i.e.\xa0two players $P = \\\\{A, B\\\\}$.\\nThose agents are exchanging a purely digital resource for a specific price.\\nThe agents negotiate over a single resource $z \\\\in \\\\mathcal{Z}$.\\nMoreover, they use a valuation function $v_i : 2^{\\\\mathcal{Z}} \\\\to \\\\mathbb{R}$.\\nAgent $A$ hence defines the value $v_A(z)$ individually as well as agent $B$ in $v_B(z)$.\\n\\nThis valuation expresses the price an agent is willing to exchange the resource for, whereby we assume that $v_A \\\\leq v_B$ if $A$ is offering the resource and $B$, is willing to pay for it. Otherwise, there would be no price for them agree on.\\nIn this simple case, we assume that the agents follow the negotiation protocol truthfully and that their utility $U$ increases when making a deal and exchanging the resource.\\nWe further assume that the agents have a way to enter such an agreement, i.e.\xa0one of them can prepare a contract that the other one can interpret and willing to commit to.\\n\\n## Contract\\n\\nThe contract $C$ is implemented as an Hashed Timelock Contract (HTLC) \\\\[8\\\\] with multiple transactions in the Lightning Network. Note that $A$ sells data $z$, and $B$ buys it for the agreed price $p$ in Satoshi. To allow agents to exchange $z$ and atomic swap is used. This protocol has been described for cross-chain transactions but is equally useful within a single chain \\\\[9\\\\].\\n\\n1. $A$ stores $z$ on IPFS receiving $H(z)$. $A$ uses this as the secret for the HTLC and sends this to $B$. As $A$ takes the Merkle root of $z$, the data can be of (almost) any size.\\n2. $B$ prepares a transaction transferring $p$ to $A$ spendable with the signature of $A$. Also, $B$ includes the spending condition $H(input) == H(z)$ based on the IPFS hash of the file. $B$ is also setting a time $t$ after which the transaction must be spent, otherwise, $B$ can redeem the locked funds. Last, $B$ sends the transaction to $A$ to sign it.\\n3. $A$ signs the transaction to agree to the trade and commits it to the channel.\\n4. $A$ reveals the $H(z)$ to issue the payment, which gives $B$ $H(z)$. $B$ obtains $z$ through IPFS.\\n\\nThis contract allowed an atomic swap of the file without the need to upload the file to Bitcoin. It requires both agents to be online which is a reasonable assumption for autonomous agents.\\nThe protocol does not handle the security of the file.\\nAny party observing $H(z)$ can access $z$ without paying any price.\\nHence, the protocol could be extended using GPG or other asymmetric encryption schemes.\\nIn that case, $A$ could take $B$\'s public RSA key to encrypt $z$ and then store it on IPFS.\\nThis would allow private trading of the file.\\n\\n## Mechanism analysis\\n\\n**Players:** $A$ and $B$ are the only players in the game. They have the same capabilities and pre-contract the same norms. Post-contract one agent has the obligation to pay for $z$ and the other has an obligation to provide $z$. The contract is *atomic*. Hence, payment and delivery occur at the same time. However, there is a possible weakness in the contract. If $A$ reveals $H(z)$ without having the file stored on IPFS any more, $B$ will not be able to retrieve the file.\\n\\n**Types:** Both players have a valuation $v(z)$. $A$ has private access to $z$.\\n\\n**Strategy:** $A$ has three actions: not reveal $H(z)$, reveal $H(z)$ and have $z$ accessible, and reveal $H(z)$ and have $z$ inaccessible. $B$ has two actions: prepare HTLC with a payment $p$ for $A$ or not. Assuming $B$\'s valuation of $v_B(z) > 0$, $B$ will propose a minimum payment. Since there is no proof of $z$ being available and the desired resource, $B$ has to account for this risk. The protocol could be improved by using concepts such as proof of replication \\\\[10\\\\].\\n$A$ will only consider revealing $H(z)$ in the proposed HTLC if $p \\\\geq v_A(z)$. Moreover, $A$ might cheat $B$ by not making $z$ available. In case $A$ expects future trades with $B$, it has a motivation to actually provide $z$. $B$ might promise a higher pay for future interactions and adjust his valuation function to the resource $z$ provided by $A$ to a higher value since $A$ is based on previous direct experience trusted.\\n\\n**Utility:** Utilities depend on the combination of strategies.\\n\\n- $B$ proposes HTLC with payment $p$ and $A$ reveals $H(z)$ with $z$ available: $u_A = p - v_A(z)$ and $u_B = v_B(z) - p$. Under the assumption that $A$ does not loose anything from selling $z$.\\n- $B$ proposes HTLC with payment $p$ and $A$ reveals $H(z)$ with $z$ unavailable: $u_A = p - v_A(z)$ and $u_B = 0 - p$.\\n- $B$ proposes HTLC with payment $p$ and $A$ does not reveal $H(z)$: $u_A = 0$ and $u_B = 0$.\\n- $B$ does not propose HTLC: $u_A = 0$ and $u_B = 0$.\\n\\n**Social choice:** Since $B$ proposes the contract, $B$ can set the social choice function. In this case, a single parameter domain is useful. The utility analysis shows that $p$ has the condition $v_A(z) \\\\leq p \\\\leq v_B(z)$. Since $B$ is not able to be sure that $z$ is available, $p$ will be low in the first tries as $B$ tries to manage his risk exposure. However, $B$ could argue that $A$ might be interested in future trades and include this as part of his utility function as an expected value. Hence, $B$ would only propose a contract if $p << v_B(z)$ since otherwise the risk is too high.\\n\\n## References\\n\\n\\\\[1\\\\] S. Fatima, S. Kraus, and M. Wooldridge, *Principles of Automated Negotiation*. Cambridge: Cambridge University Press, 2014 \\\\[Online\\\\]. Available: <http://ebooks.cambridge.org/ref/id/CBO9780511751691>\\n\\n\\\\[2\\\\] S. Nakamoto, \\"Bitcoin: A peer-to-peer electronic cash system,\\" 2008.\\n\\n\\\\[3\\\\] Bitcoin Wiki, \\"Script.\\" 2018 \\\\[Online\\\\]. Available: [https://en.bitcoin.it/wiki/Script{\\\\\\\\\\\\#}Opcodes](https://en.bitcoin.it/wiki/Script{\\\\#}Opcodes). \\\\[Accessed: 27-Jun-2018\\\\]\\n\\n\\\\[4\\\\] N. Szabo, \\"Formalizing and Securing Relationships on Public Networks.\\" 1997 \\\\[Online\\\\]. Available: <http://ojphi.org/ojs/index.php/fm/article/view/548/469>. \\\\[Accessed: 07-Apr-2017\\\\]\\n\\n\\\\[5\\\\] T. W. Sandholm and V. R. Lesser, \\"Leveled Commitment Contracts and Strategic Breach,\\" *Games and Economic Behavior*, vol. 35, nos. 1-2, pp. 212--270, 2001.\\n\\n\\\\[6\\\\] N. Nisan, T. Roughgarden, E. Tardos, and V. V. Vazirani, *Algorithmic Game Theory*, vol. 1. Cambridge: Cambridge University Press, 2007, pp. 1--754 \\\\[Online\\\\]. Available: [http://portal.acm.org/citation.cfm?doid=1785414.1785439 http://ebooks.cambridge.org/ref/id/CBO9780511800481](http://portal.acm.org/citation.cfm?doid=1785414.1785439 http://ebooks.cambridge.org/ref/id/CBO9780511800481)\\n\\n\\\\[7\\\\] N. Nisan and A. Ronen, \\"Algorithmic Mechanism Design,\\" *Games and Economic Behavior*, vol. 35, nos. 1-2, pp. 166--196, Apr. 2001 \\\\[Online\\\\]. Available: <http://linkinghub.elsevier.com/retrieve/pii/S089982569990790X>\\n\\n\\\\[8\\\\] Bitcoin Wiki, \\"Hashed Timelock Contracts.\\" 2018 \\\\[Online\\\\]. Available: [https://en.bitcoin.it/wiki/Hashed{\\\\\\\\\\\\_}Timelock{\\\\\\\\\\\\_}Contracts](https://en.bitcoin.it/wiki/Hashed{\\\\_}Timelock{\\\\_}Contracts). \\\\[Accessed: 28-Jun-2018\\\\]\\n\\n\\\\[9\\\\] I. Bentov *et al.*, \\"Tesseract: Real-Time Cryptocurrency Exchange using Trusted Hardware,\\" 2017 \\\\[Online\\\\]. Available: [http://www.cs.cornell.edu/{\\\\~}iddo/RTExchSGX.pdf](http://www.cs.cornell.edu/{~}iddo/RTExchSGX.pdf)\\n\\n\\\\[10\\\\] A. Juels and B. Kaliski Jr., \\"Pors: Proofs of retrievability for large files,\\" *Proceedings of the ACM Conference on Computer and Communications Security*, pp. 584--597, 2007 \\\\[Online\\\\]. Available: [http://www.scopus.com/inward/record.url?eid=2-s2.0-74049101079{\\\\\\\\&}partnerID=40{\\\\\\\\&}md5=83cf075b3704d4fe5bfb2ccf38c39362](http://www.scopus.com/inward/record.url?eid=2-s2.0-74049101079{\\\\&}partnerID=40{\\\\&}md5=83cf075b3704d4fe5bfb2ccf38c39362)"},{"id":"ethereum-python-integration","metadata":{"permalink":"/blog/ethereum-python-integration","editUrl":"https://github.com/nud3l/nud3l.github.io/blog/2017-02-14-ethereum-python-integration.md","source":"@site/blog/2017-02-14-ethereum-python-integration.md","title":"Integrating Python and Ethereum","description":"In Ethereum and other blockchains there are still a lot of proof of concept implementation and developers trying out how to cope with the new concepts. As part of the dInvest post series I was also looking into Ethereum and trying to implement a hedge fund in a blockchain. In a previous post I discussed how to get a quantitative framework in python up and running. In this post I will write how to integrate python programs with Ethereum smart contracts. For one reason or another you might be also faced with the issue, that although Ethereum offers a Turing-complete language not everything is actually doable there.","date":"2017-02-14T00:00:00.000Z","formattedDate":"February 14, 2017","tags":[{"label":"dinvest","permalink":"/blog/tags/dinvest"},{"label":"blockchain","permalink":"/blog/tags/blockchain"},{"label":"ethereum","permalink":"/blog/tags/ethereum"},{"label":"python","permalink":"/blog/tags/python"}],"readingTime":4.61,"hasTruncateMarker":false,"authors":[{"name":"Dominik Harz","title":"CTO Interlay","url":"https://harz.dev","imageURL":"https://github.com/nud3l.png","key":"dom"}],"frontMatter":{"slug":"ethereum-python-integration","title":"Integrating Python and Ethereum","tags":["dinvest","blockchain","ethereum","python"],"authors":"dom"},"prevItem":{"title":"Analyzing Bitcoin smart contracts from a mechanism design perspective","permalink":"/blog/bitcoin-smart-contracts-mechanism-design"},"nextItem":{"title":"Quantitative finance with zipline","permalink":"/blog/quantitative-finance-zipline"}},"content":"In Ethereum and other blockchains there are still a lot of proof of concept implementation and developers trying out how to cope with the new concepts. As part of the dInvest post series I was also looking into Ethereum and trying to implement a hedge fund in a blockchain. In a previous post I discussed how to get a quantitative framework in python up and running. In this post I will write how to integrate python programs with Ethereum smart contracts. For one reason or another you might be also faced with the issue, that although Ethereum offers a Turing-complete language not everything is actually doable there.\\n\\nLet\'s say you have created one of the [simple tutorial contracts in Ethereum](www.ethereum.org/greeter) and now want to look at something more advanced. I personally liked the [Hitchhiker\'s Guide to Smart Contracts](https://medium.com/zeppelin-blog/the-hitchhikers-guide-to-smart-contracts-in-ethereum-848f08001f05##.3dxx4rysl) by Manuel Ar\xe1oz to get started with more complex code, setup testrpc, and truffle. Take a look at it.\\n\\n## dInvest smart contract\\ndInvest is composed of one smart contract that is responsible for making investments, verifying investment\\ncriteria and distribution of returns. The contract exposes public functions to create new investments and\\nfor withdrawal which will act as main functions of a hedge fund. Users of the hedge fund are identified\\nby their Ethereum address which is equivalent for the public key. Suggestion of investment strategies and\\nstrategy execution are done in different agents that also have Ethereum addresses. These agents are set by\\nthe contract creator only.\\nWhen a user is creating an investment it is possible to specify a list of industry sectors identified by a\\ntwo digit number based on the Standard Industrial Classification codes. These sectors will be identified\\nas a black list when making the investments. Therefore user have the ability control the sectors which the\\nhedge fund will invest on.\\n\\n\\nThe contract can be found in [the GitHub repo](github.com/nud3l/dInvest/blob/master/solidity/contracts/HedgeContract1.sol).\\n\\n## Interaction with smart contracts\\nTo interact with smart contracts, there are a couple of option including RPC or a JavaScript API. I found the easiest way to interact with Ethereum smart contracts from other programs (like python programs) was using their [web3 JavaScript API](github.com/ethereum/wiki/wiki/JavaScript-API). As the majority of dInvest is written in python, I wanted to stick to the language and not include JS as well. Luckily, there is a [web3 implementation in python](github.com/pipermerriam/web3.py). To get it up and running for the dInvest setting I switched to the virtualenv, where I also installed zipline and then install web3 simply with ```pip install web3```.\\n\\nUsing web3, there are three steps to get you up and running to interact with your smart contract:\\n\\n1. Getting your ABI\\n2. Setup the RPC connection\\n3. Interact with the smart contract\\n\\nIn the next sections, I will go into detail how to achieve the three steps. I am using this mostly as a python module for other programs. In the end our python module structure might look like this:\\n\\n```\\ncontract\\n|-- __init__.py\\n|-- ContractHandler.py\\n|-- your-contract-name.json\\n```\\n\\n## Getting your ABI\\nNow, to interact with any smart contract you need the [Application Binary Interface(ABI)](github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI) defined by the contract. The ABI is a static, strongly typed interface. Whenever you create a new contract or change an existing one, chances are your ABI changes as well. In my experience the easiest way to get the current ABI of a smart contract (which might be yours or any contract you have the source code available) is to go to [https://ethereum.github.io/browser-solidity/](https://ethereum.github.io/browser-solidity/) and copy/paste your code there. Then press the \\"Compile\\" button on the upper right side and copy the entire string in the \\"Interface\\" field into a ```your-contract-name.json``` file. Once you have that JSON, your web3 interface will know how to interact with the contract.\\n\\n## Setting up the RPC provider\\nAs a next step you will need to connect to the RPC provider. In your python file (e.g. ```ContractHandler.py```) include those lines of code:\\n\\n```python\\nfrom web3 import Web3, TestRPCProvider\\n\\nclass ContractHandler:\\n  def __init__(self):\\n    self.web3 = Web3(RPCProvider(host=\'localhost\', port=\'8545\'))\\n    with open(str(path.join(dir_path, \'contract_abi.json\')), \'r\') as abi_definition:\\n      self.abi = json.load(abi_definition)\\n    self.contract_address = your_contract_address\\n    self.contract = self.web3.eth.contract(self.abi, self.contract_address)\\n```\\n\\n\\nI prefer having my configurations in a separate file. There are many ways to do it and it seems like there is no standard in python. I guess using a txt file is not the best option though and I plan to switch to yml soon. See also here [https://martin-thoma.com/configuration-files-in-python/](https://martin-thoma.com/configuration-files-in-python/). Make sure to run your favorite Ethereum client before starting your program (e.g. ```geth --rpc```).\\n\\n## Interacting with the smart contract\\nNote: Before interacting with your own account you need to unlock it first. This is achieved in web3 via:\\n\\n```python\\nself.web3.personal.unlockAccount(your_ethereum_account, your_ethereum_password)\\n```\\n\\nThere are some standard web3 calls you can make, like getting the current balance of an account in wei:\\n\\n```python\\nwei_balance = self.web3.eth.getBalance(some_ethereum_address)\\n```\\n\\nIn case you want to call a function in the contract you can do this by calling the command as defined by the contract ABI. In our dInvest example there is a contract call which returns the blacklisted companies for our sustainable investment. It is callable with:\\n\\n```python\\nblacklist = self.contract.call().blackListCompanies()\\n```\\n\\nThere are some more examples in the [GitHub code available](https://github.com/nud3l/dInvest/blob/master/trading/contract/ContractHandler.py).\\n\\n## Final note\\nAs a final note, I would like to point out that there are other blockchain solutions like [Hyperledger Fabric](hyperledger-fabric.readthedocs.io/en/latest/) or [Tendermint](tendermint.com) that aim to solve issues around compatibility with other programming language, transaction throughput etc. As they are permissioned blockchains I haven\'t yet given them a try, but might be interesting to take a look at."},{"id":"quantitative-finance-zipline","metadata":{"permalink":"/blog/quantitative-finance-zipline","editUrl":"https://github.com/nud3l/nud3l.github.io/blog/2017-02-10-quantitative-finance-with-zipline/index.md","source":"@site/blog/2017-02-10-quantitative-finance-with-zipline/index.md","title":"Quantitative finance with zipline","description":"As stated in the dInvest post series the idea is to build a hedge fund in a blockchain. Due to computational limitations, it is not feasible to implement investment agents in the blockchain. In dInvest an investment agent should do the following: (1) Get a list of all available financial assets to trade; (2) based on the data given (i.e. financial data and fundamentals data) make a recommendation which assets to buy; (3) keep track of which assets the agent is currently holding; and (4) send the recommended assets to buy to the blockchain. In this blog post I will cover the first three tasks. But what does a hedge fund actually do and how do financial investment strategies look like? I had taken some courses in my undergrad on international finance, but as a computer scientist I had to learn some new concepts while doing this project.","date":"2017-02-10T00:00:00.000Z","formattedDate":"February 10, 2017","tags":[{"label":"quant","permalink":"/blog/tags/quant"},{"label":"finance","permalink":"/blog/tags/finance"},{"label":"zipline","permalink":"/blog/tags/zipline"},{"label":"python","permalink":"/blog/tags/python"}],"readingTime":9.065,"hasTruncateMarker":false,"authors":[{"name":"Dominik Harz","title":"CTO Interlay","url":"https://harz.dev","imageURL":"https://github.com/nud3l.png","key":"dom"}],"frontMatter":{"slug":"quantitative-finance-zipline","title":"Quantitative finance with zipline","tags":["quant","finance","zipline","python"],"authors":"dom"},"prevItem":{"title":"Integrating Python and Ethereum","permalink":"/blog/ethereum-python-integration"},"nextItem":{"title":"Breaking captchas: Using deep learning to automatically break CAPTCHAs","permalink":"/blog/breaking-captchas"}},"content":"As stated in the [dInvest post series]({% post_url 2017-01-10-dinvest %}) the idea is to build a hedge fund in a blockchain. Due to computational limitations, it is not feasible to implement investment agents in the blockchain. In dInvest an investment agent should do the following: (1) Get a list of all available financial assets to trade; (2) based on the data given (i.e. financial data and fundamentals data) make a recommendation which assets to buy; (3) keep track of which assets the agent is currently holding; and (4) send the recommended assets to buy to the blockchain. In this blog post I will cover the first three tasks. But what does a hedge fund actually do and how do financial investment strategies look like? I had taken some courses in my undergrad on international finance, but as a computer scientist I had to learn some new concepts while doing this project.\\n\\n\\nFinancial investments can take different forms. A hedge fund offers multiple individuals to acquire a part of the pooled investment, which itself invests in publicly\\ntraded financial assets. It is measured according to its absolute returns [1]. A manager administrates the\\ninvestment of the hedge fund and takes the decisions to buy, sell, or hold financial assets to balance absolute\\nreturns and risks. A hedge fund may apply different strategies. Hedge funds can follow one specific strategy, mix\\nestablished strategies, or create a fund out of hedge funds to diversify [2]. The majority of hedge fund\\nstrategies try to optimize the absolute return and risk based on financial indicators of the assets to be invested\\nin. An overview of the different strategies that are currently applied by different hedge funds is provided by\\nHFR, Inc in [3]. Measuring the performance of hedge funds as well as specific influence factors is a wide\\nresearch area, which is covered in more detail in our report.\\n\\n## Measuring success of investments\\n\\nA common standard in literature and the investment practice to compare hedge funds is based on\\ntheir absolute returns, Sharpe ratio, alpha and beta as well as a comparison to benchmarks [2].\\n\\n- Returns: The return of the fund is influenced by how well the strategy is able to determine assets that are increasing (for long buys) or decreasing (for short buys) in value over time.\\n- Sharpe: With the Sharpe ratio one can determine the return in respect to the risk involved. The Sharpe ratio is calculated by dividing the sum of the asset return and a benchmark return by the standard deviation of the asset return. The higher the Sharpe ratio, the higher the return with the same risk or the lower the risk with same return.\\n- Alpha: The alpha value expresses the risk-adjusted performance of the fund in comparison to a benchmark. An alpha of zero means exact performance as the benchmark. A positive value indicates outperforming the benchmark and a negative value represents falling behind the benchmark.\\n- Beta: The beta value shows the volatility of the fund in comparison to a benchmark. The beta value baseline is one and represents the same volatility as the benchmark. A value below one indicates a lower volatility and consequently a value above one a higher volatility than the benchmark.\\n\\n\\n## Quantitiative finance\\n\\nTo implement an investment strategy, certain rule sets are developed and applied. Quantitative finance\\n\u201dtranslates\u201d economic models into the mathematical world and allows to apply for example stochastic\\nanalysis over shares or calculate the value of derivatives [4]. Quantitative finance techniques express\\ninvestment strategies in mathematical formulas and thus enables a translation into an algorithm [4].\\nWhen starting out with dInvest, we were looking into existing quantitative frameworks, that offer us (1) a simulation environment\\nto test our algorithms without using actual money, (2) realistic conditions of the trading market, such as\\nfees and process delays, (3) is able to trade shares and derivatives based on historical data to test our\\nalgorithm, (4) provide little delay (lower than 10 minutes) in trading current assets, and (5) is able to be\\ncontrolled using a programming language (such as Python, Java, or Scala). We evaluated several solutions\\ndecided to use the open source implementation of the Quantopian framework [zipline](github.com/quantopian/zipline).\\n\\n## Getting started with zipline\\n\\nZipline is based on python and is able to run with python 2 and 3. Quantopian has created a [beginners tutorial](www.zipline.io/beginner-tutorial.html) on their website. Before going into the details of zipline, let us look into how to set it up locally. Note: I will be using python3 throughout this post.\\nTo install zipline you first need all the required C extensions. For Debian based distributions use the command shown below, otherwise there are some more details [provided here](www.zipline.io/install.html).\\n\\n```\\nsudo apt-get install libatlas-base-dev python-dev gfortran pkg-config libfreetype6-dev\\n```\\n\\nI then created a virtual environment for Zipline. If you have never setup a virtualenv follow [this tutorial](http://docs.python-guide.org/en/latest/dev/virtualenvs/). In case you want to use pyhton3 like me, make sure to use the ```python3``` executable. Also, when trying python2 I ran into a couple of issues as Linux Mint uses older versions of python2, which seem to be incompatible with the required version of numpy. When you setup your virtualenv, run ```pip install zipline``` from the terminal with your virtualenv . This will install all the required packages including numpy and most likely take some time.\\n\\n## The first investment algorithm\\n\\nIn the ```/zipline/examples``` folder you will find some example algorithms to try out. In their beginners tutorial the zipline authors describe some of the algorithms, how they are generally structured and how to execute them. I will go into more detail about having a value investment algorithm and not take one of the example algorithms.\\n\\nThe algorithm to be implemented is inspired by Benjamin Graham [6]\\n1. Select shares and derivatives of companies with a market capitalization of minimum 100 million dollars\\n2. Determine the SIC code of each asset [5] and exclude the ones contained in the blacklist from the hedge fund\\n3. Based on the sectors of the companies find the two sectors with the price of assets per earning ratio (PE ratio)\\n4. Invest every month in all the companies listed in the two sectors\\n\\nLet\'s take a look at our [algorithm](https://github.com/nud3l/dInvest/blob/master/trading/recommender/InvestHandlerSimple.py).\\nIt is basically taken from the web-based version of zipline called Quantopian and can be found [here](https://www.quantopian.com/posts/grahamfundmantals-algo-simple-screening-on-benjamin-graham-number-fundamentals). I have tried to include quite some comments, so if you are familiar with python then the code should be quite readable. Zipline does not include the full functionality and data to realize the investment algorithm. The market capitalization data, sector codes, and PE ratio are not accessible from zipline. For a quick overview of the current code and the changes I made, I will go through the main functions. Also, please note that I only used free sources of financial data. There seem to be a lot of other sources available, but they have their price tag.\\n\\n```initialize(context)``` Defines the number of sectors we are interested in and also schedules to execution of our algorithm for back-testing.\\n\\n```rebalance(context, data)``` This essentially takes to selected assets and distributes them evenly into our portfolio.\\n\\n```get_fundamentals(context, data)``` In Quantopian this is fairly easy, since the Morningstar fundamentals dataset is included. However, in zipline I had to find a workaround. Quandl offers the SF0 fundamentals for free: [www.quandl.com/data/SF0-Free-US-Fundamentals-Data](www.quandl.com/data/SF0-Free-US-Fundamentals-Data). To get a full view of the data, I choose to download the whole data as a CSV file and automated the process. An example of how to do this can be found in the ```TradeHandler.getData(self)``` function [here](https://github.com/nud3l/dInvest/blob/master/trading/trader/TradeHandler.py).\\n\\n```get_sectors(key)``` Again, this is included in Quantopian, but needs a manual workaround. To get the sector codes it is quite simple. You need to download a txt file, which includes the sector codes and the function will read them into a dict.\\n\\n\\n```get_sector_code()``` Also, this part is included in Quantopian. Here we download a JSON file to get a mapping of sector codes to the financial assets we are trading.\\n\\nTo analyse the performance of the investment algorithm the absolute returns, Sharpe, alpha, and beta for the\\nperiod of January 1, 2009 to November 15, 2016 is compared. The investment algorithm uses the Quandl\\nfinancial data i.e. opening and closing prices of specific assets during that period [8]. The algorithm is executed\\nmultiple times. First, no sectors are excluded and second, an\\nexclusion list based on sectors is used. Defense, beer and alcohol, tobacco, and coal industry are excluded based\\non ESG criteria and common practices [9].\\nThe first graph in the figure below presents the returns achieved by the unrestricted\\nalgorithm, the algorithm with single excluded sectors, and the benchmark return. These returns show that\\nunrestricted and single excluded algorithms have overall a higher profit than the benchmark. The second graph in the figure\\ndisplays a combination of two excluded sectors and the benchmark return, while the third graph elaborates on the\\ncombinations of three and all four sectors excluded.\\nA single or combination of exclusions constantly perform better than the benchmark until\\nbeginning of 2012. Then the unrestricted algorithm as well as the single exclusion of defense and alcohol\\nexclusion and also the combination of tobacco and coal, defense and alcohol, defense and coal exclusions\\ndrop until they recover in 2014. The other single and combination algorithms do not show this drop, but also\\nhave a strong increase in returns in 2014. Then all variations show high volatility. The drop in 2012 in the\\nunrestricted algorithm is caused by three of the sectors it is investing in. When tobacco is restricted, there is\\nno strong drop in 2012. However, if not also in combination defense and/or coal is restricted the algorithm\\nselects either of the two industries instead and another drop occurs. In the third graph of the figure these exclusions are\\ncombined and no significant drop occurs, however the volatility remains.\\n\\n\\n<img src=\\"{{ site.url }}/images/blog/dinvest/investment_return_single.png\\" alt=\\"\\" width=\\"550\\"/>\\n\\n<img src=\\"{{ site.url }}/images/blog/dinvest/investment_return_double.png\\" alt=\\"\\" width=\\"550\\"/>\\n\\n<img src=\\"{{ site.url }}/images/blog/dinvest/investment_return_triple.png\\" alt=\\"\\" width=\\"550\\"/>\\n\\n\\n\\nThere is further analysis and discussion of the results in our [report](https://goo.gl/T74EGE).\\n\\n\\n\\n## References\\n\\n1. D. Harper. (2016) Hedge funds hunt for upside, regardless of the market. [Online]. Available: http://www.investopedia.com/articles/03/112603.asp\\n2. M. Agarwal, Hedge Fund Strategies. John Wiley & Sons, Inc., 2009, pp. 45\u201355. ISBN 9781118258187. [Online]. Available: http://dx.doi.org/10.1002/9781118258187.ch4\\n3. Hedge Fund Research. (2016) HFR hedge fund strategy classification system. [Online]. Available: https://www.hedgefundresearch.com/hfr-hedge-fund-strategy-classification-system\\n4. P. Wilmott, Paul Wilmott on quantitative finance. John Wiley & Sons, 2013.\\n5. U.S.D. of Labor. (2016) SIC division structure. [Online]. Available: https://www.osha.gov/pls/imis/sic_manual.html\\n6. B. Graham and D. Dodd, Security Analysis: Sixth Edition, ser. Security Analysis Prior Editions. McGraw-Hill Education, 2008.\\n7. Quantopian. (2016) zipline: Pythonic algorithmic trading library. [Online]. Available: https://github.com/quantopian/zipline/\\n8. Quandl. (2016) Quandl: financial database. [Online]. Available: https://www.quandl.com/browse?idx=database-browser\\n9. J. R. Evans and D. Peiris, \u201cThe relationship between environmental social governance factors and stock returns,\u201d UNSW Australian School of Business Research Paper No. 2010ACTL02, 2010."},{"id":"breaking-captchas","metadata":{"permalink":"/blog/breaking-captchas","editUrl":"https://github.com/nud3l/nud3l.github.io/blog/2017-01-12-breaking-captcha/index.md","source":"@site/blog/2017-01-12-breaking-captcha/index.md","title":"Breaking captchas: Using deep learning to automatically break CAPTCHAs","description":"Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) is a way of differentiating humans and machines and was coined by von Ahn, Blum, Hopper, and Langford [5]. The core idea is that reading distorted letters, numbers, or images is achievable for a human but very hard or impossible for a computer. CAPTCHAs might look like the one below. Most likely the reader has already seen one, when trying to register at a website or write a comment online.","date":"2017-01-12T00:00:00.000Z","formattedDate":"January 12, 2017","tags":[{"label":"ai","permalink":"/blog/tags/ai"},{"label":"deep learning","permalink":"/blog/tags/deep-learning"},{"label":"captcha","permalink":"/blog/tags/captcha"},{"label":"breaking captchas","permalink":"/blog/tags/breaking-captchas"},{"label":"machine learning","permalink":"/blog/tags/machine-learning"},{"label":"python","permalink":"/blog/tags/python"},{"label":"tensorflow","permalink":"/blog/tags/tensorflow"}],"readingTime":12.07,"hasTruncateMarker":false,"authors":[{"name":"Tharidu Fernando","url":"https://www.linkedin.com/in/tharidu-fernando/","key":"Tharidu"},{"name":"Akash Singh","url":"https://www.linkedin.com/in/akash13singh/","key":"Akash"},{"name":"Dominik Harz","title":"CTO Interlay","url":"https://harz.dev","imageURL":"https://github.com/nud3l.png","key":"dom"}],"frontMatter":{"slug":"breaking-captchas","title":"Breaking captchas: Using deep learning to automatically break CAPTCHAs","tags":["ai","deep learning","captcha","breaking captchas","machine learning","python","tensorflow"],"authors":["Tharidu","Akash","dom"]},"prevItem":{"title":"Quantitative finance with zipline","permalink":"/blog/quantitative-finance-zipline"},"nextItem":{"title":"dInvest - hedge fund on a blockchain","permalink":"/blog/dinvest-hedge-fund-on-a-blockchain"}},"content":"Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) is a way of differentiating humans and machines and was coined by von Ahn, Blum, Hopper, and Langford [5]. The core idea is that reading distorted letters, numbers, or images is achievable for a human but very hard or impossible for a computer. CAPTCHAs might look like the one below. Most likely the reader has already seen one, when trying to register at a website or write a comment online.\\n\\n![Penguin-Pal_Captcha](Penguin-Pal_Captcha.png)\\n\\nThere are several use cases for CAPTCHAs, which includes the ones presented in [6]: Preventing comment spam, protect website registration, protect e-mail addresses from scrappers, protect online polls, preventing dictionary attacks, and block/hinder search engine bots.\\n\\nCAPTCHAs do not give a guarantee that it prevents these cases every time as there are known attack vectors. These include cheap or unwitting human labor, insecure implementation, and machine learning based attacks. We will not go into detail on insecure implementations, as the focus of this article are deep learning based approaches.\\n\\n## Human-based CAPTCHA breaking\\n\\nOut of curiosity and to compare results achieved by machine learning approaches, we take a look at the human based approach. For example [BypassCAPTCHA](http://bypassCAPTCHA.com/order1.php) offers breaking CAPTCHAs with cheap human labor in packages (e.g. 20,000 CAPTCHAs for 130$). There are also other services including [Image Typerz](http://www.imagetyperz.com/Forms/bypassCAPTCHA.aspx), [ExpertDecoders](http://expertdecoders.com/), and [9kw.eu](https://www.9kw.eu/). There are also hybrid solutions that use both OCR and human labor like [DeathByCAPTCHA](http://deathbyCAPTCHA.com/user/login). These vendors list the following accuracies and response times (averages):\\n\\n| Service | Accuracy (daily average) | Response Time (daily average)|\\n|---------|---------:|--------------:|\\n| BypassCAPTCHA | N/A | N/A |\\n| Image Typerz | 95% | 10+ sec |\\n| ExpertDecoders | 85% | 12 sec |\\n| CAPTCHABOSS (premium version of ExpertDecoders) | 99% | 8 sec |\\n| 9kw.eu | N/A | 30 sec |\\n| DeathByCAPTCHA | 96.8% | 10 sec |\\n\\nThe values are advertised and self-reported. We did not conduct any verification of the stated numbers, but it can give an orientation on human performance and serves as a reference for our machine learning algorithms.\\n\\n## Learning-based CAPTCHA breaking\\n\\nCAPTCHAs are based on unsolved or hard AI problems. However, with the progress of AI techniques and computing power, sequences of characters or CAPTCHAs can be recognized as shown by Goodfellow et al. in [1], Hong et al. in [2], Bursztein et al. in [3] and [7], and Stark et al. in [4] using deep learning techniques. Goodfellow et al. predict numbers from Goolge Street View images directly (without pre-processing) utilizing a CNN. They make use of  [DistBelief](https://research.google.com/pubs/pub40565.html) by Dean et al. to scale the learning to multiple computers and to avoid out of memory issues [1]. This technique was later on used to solve CAPTCHAs, whereby the researched achieved an [accuracy of up to 99.8%](http://www.zdnet.com/article/google-algorithm-busts-CAPTCHA-with-99-8-percent-accuracy/). Hong et al. pre-process CAPTCHAs to rotate them and segment the characters. Afterwards they apply a CNN with three convolutional layers and two fully connected layers [2]. Bursztein et al. use pre-processing, segmentation, and recognition techniques (based on KNN) and later on various CNNs to detect CAPTCHAs from multiple websites including Baidu, Wikipedia, reCAPTCHA, and Yahoo [3],[7]. Stark et al. researched a way of detecting CAPTCHAs with limited testing data. They use a technique called Active Learning to feed the network with new training data, where the added data has a high classification uncertainty, to improve the performance overall [4]. The below table gives an overview of the reported accuracies in the different papers and blog posts.\\n\\n| Researcher | Dataset | Technique | Accuracy (maximum) | Reference |\\n|-----------:|--------:|----------:|---------:|----------:|\\n| Goodfellow et al. | Google Street View image files | CNN with DistBelief | 96% | [1] |\\n| Hong et al. | Microsoft CAPTCHAs | Preprocessing, segementation and CNN | 57% | [2] |\\n| Stark et al. | Cool PHP CAPTCHA generated CAPTCHAs | CNN with Active Deep Learning | 90% | [4] |\\n| Bursztein et al. | Baidu, CNN, eBay, ReCAPTCHA, Wikipedia, Yahoo CAPTCHAs | Reinforcement Learning, k-Nearest Neighbour | 54% (on Baidu) | [7] |\\n| Bursztein | Simple CAPTCHA | CNN | 92% | [3] |\\n| Bursztein | Simple CAPTCHA | RNN | 96% | [8] |\\n\\n## Current state of CAPTCHAs\\n\\n\\nGoogle has introduced [NoCAPTCHA](https://www.google.com/reCAPTCHA/intro/index.html) in December 2014. This introduces multiply new features including evaluation based on cookies, movement of the mouse, and recognition of multiple images. Google announced to introduce an [invisible CAPTCHA](https://www.google.com/reCAPTCHA/intro/comingsoon/invisiblebeta.html) to get rid of the checkbox.\\n\\n![](noCaptcha-mobile.png.gif)\\n\\nThe previous version of [reCAPTCHA](https://security.googleblog.com/2014/12/are-you-robot-introducing-no-CAPTCHA.html) was very popular on many websites. It included typically two words with rotation and had an audio option. Further CAPTCHA techniques can include simple logic or math questions, image recognition, recognition of friends (social CAPTCHA), or user interaction (like playing a game) [9].\\n\\n![](red-captcha.png)\\n\\n## Our objectives and motivation\\n\\nThe aim of the project is to break CAPTCHAs using deep learning technologies without pre-segmentation. Initially we focus on simple CAPTCHAs to evaluate the performance and move into more complex CAPTCHAs. The training dataset is generated from an open source CAPTCHA generation software. Tensorflow is used to create and train a neural network.\\n\\n## Creating the datasets\\n\\nWe are generating the datasets using a Java based CAPTCHA generator ([SimpleCAPTCHA](http://simpleCAPTCHA.sourceforge.net/)). We have created the following datasets.\\n\\n| Description | Size | Training samples | Test samples |\\n|:------------|-----:|-----------------:|-------------:|\\n| Digits only | 38 MB | 9502 | 100 |\\n| Digits and characters | 197 MB | 49796 | 100 |\\n| Digits and characters with rotation | 39 MB | 10000 | 100 |\\n| Digits and characters with rotation | 198 MB | 49782 | 500 |\\n| Digits and characters with rotation | 777 MB | 196926 | 500 |\\n\\nEach dataset contains jpeg images containing a CAPTCHA with five characters. The characters are lowercase (a-z) or numbers (0-9). We used the fonts \\"Arial\\" and \\"Courier\\" with noise. An example of the created CAPTCHAs is displayed below. Our intention was to mimic the CAPTCHAs created by [Microsoft](https://courses.csail.mit.edu/6.857/2015/files/hong-lopezpineda-rajendran-recansens.pdf).\\nWe have extended SimpleCAPTCHA library in order to get character rotation, outlines in CAPTCHAs to achieve the same look of Microsoft CAPTCHAs.\\n\\n![54563](54563.jpg)\\n![5p23r](5p23r.jpg)\\n![ycn2m](ycn2m.jpg)\\n\\nGenerated CAPTCHAs will be 152x80 greyscale images. This resolution is chosen because it is small enough to reduce memory footprint when training the CNN and it is also enough to recognize the CAPTCHA easily.\\n\\n## Deep CNN model\\n\\nBased on the research in [1], [3] and [4] we use a deep CNN with three ReLU layers and two fully connected layers to solve the CAPTCHAs.\\nEach digit is represented by 36 neurons in the output layer.\\nThe three convolutional layers with ReLU activation function have the sizes of 32, 64, and 128.\\n5x5 filter size was used in all layers. After each convolutional layer there is a max pooling of 2.\\nAfter the last convolutional layer, there is a fully connected layer with ReLU of size 1024 and finally another fully connected layer that has an output size of 180. In the ReLU layers, a dropout of 0.75 is applied.\\n\\nIn the output layer, digits 0-9 will be represented by 1 to 10 neurons and, characters a to z will be represented by 11 to 36 neurons. Therefore, there are 5 x 36 neurons which will identify the CAPTCHA. The network will output the predictions for all 5 digits and each digit is calculated by the max probability of its 36 neurons. We have set the learning rate as 0.001.\\n\\n![CNN](cnn.png)\\n\\n## Results and discussion\\n\\nFirst, we trained the CNN with 10000 five letter and digit CAPTCHAs without rotation on a GTX660M. We had 100 batches with a batch size of 100 and ran it for 20 epochs. The hyperparameters were set as described in the previous section. The figure below shows that the network did not perform well with these settings. We then increased the training size to 50000 CAPTCHAs, but the results stayed the same. We then tried with 10000 simplified CAPTCHAs with only five digits without rotation. However, this still did not improve our situation. We noted that the loss function reduced quite quickly and stayed constant. We hence introduced another convolutional layer to the network to allow it to further differentiate the digits. Again, this resulted in almost the same result.\\n\\n![DigitsOnly660M](digits_only_660M.png) <br />\\n*CNN with three conv. layers and two fully connected layers accuracy of CAPTCHAs with five digits or lowercase letters without rotation. Training in 100 batches and 10000 training samples.*\\n\\nThese results match the ones presented in [4]. The authors then introduce Active Learning to circumvent the problem. In [1] a larger amount of samples is used. However, we do not have sufficient computing power available to use millions of images as training data. Also, in [3] the batch size is larger, resulting in a considerably higher accuracy. We decided to change our batch size, but required a more powerful GPU for that. Hence, we used a Nvidia Tesla K80 from AWS to conduct our training. We also changed the CNN back to three conv. layers and two fully connected layers. On the simple case with five digit CAPTCHAs without rotation we used 39250 CAPTCHAs in 157 batches and 10 epochs. We conducted testing with a very small dataset of 100 CAPTCHAs. The results did improve considerably as shown in the figure below. We managed to achieve a best training error of 94.9% and a test error of 99.2%. The very high test accuracy is quite likely also caused by the small amount of test items. However, running a K80 in AWS is quite costly and therefore we kept the test set to a minimum also in the upcoming experiments.\\n\\n![DigitsOnly](digits_only.png) <br />\\n*CNN with three conv. layers and two fully connected layers accuracy of CAPTCHAs with five digits without rotation. Training in 157 batches, 39250 training samples, and testing with 100 CAPTCHAs.*\\n\\nWe then tried with a bit more complex CAPTCHAs with digits and lowercase characters. We used 49750 training and 100 test CAPTCHAs with the same CNN used in the simple case above. The figure below presents our results and shows that we can achieve a training accuracy of 65% and a test accuracy above 80% in these cases. We stopped the CNN prematurely after 10 epochs to try more complex use cases.\\n\\n![DigitsChar](digits_char.png) <br />\\n*CNN with three conv. layers and two fully connected layers accuracy of CAPTCHAs with five digits or lowercase letters without rotation. Training in 199 batches, 49750 training samples, and testing with 500 CAPTCHAs.*\\n\\n\\nNext, we added rotation to our CAPTCHAs and trained the CNN on 49782 samples. This resulted in almost random result with an accuracy around 10%. We thus increased the samples to 196926 and tested it on 500. Again, we kept the same hyperparameters as presented in the model section. This time we trained for 15 epochs, to prevent premature interruption of the training. Our results are presented in the figure below. With the increased training size we achieve a training accuracy of 97.1% and a test accuracy of 99.5%. However, this is again on a very small test set.\\n![DigitsCharRot](digits_char_rot.png) <br />\\n*CNN with three conv. layers and two fully connected layers accuracy of CAPTCHAs with five digits or lowercase letters with rotation. Training in 787 batches, 196926 training samples, and testing with 500 CAPTCHAs.*\\n\\n\\nFrom the tests conducted above, we have a few examples to show correct and false predictions.\\n\\n| **Correctly classified** | **Incorrectly classified** |\\n|:-------------------------|:---------------------------|\\n| Prediction: 54563 Image: ![54563](54563.jpg) | Prediction: 8229**8** Image: ![82290](82290.jpg) |\\n| Prediction: grh56 Image: ![grh56](grh56.jpg) | Prediction: **k**76ap Image: ![h76ap](h76ap.jpg) |\\n| Prediction: fb2x4 Image: ![fb2x4](fb2x4.jpg) | Prediction: fffg**r** Image: ![k76ap](fffgf.jpg) |\\n\\n## Conclusion\\n\\nWith this project we have shown that it is possible to create large enough datasets automatically to mimic certain CAPTCHAs (i.e. Microsoft). This provides large labeled datasets, which serve as a foundation to train neural networks. We have chosen to use two different CNNs with three and four convolutional layer and two fully connected layers. Our experiments show however, that adding more layers to the network did not increase the accuracy.\\nWe noticed that optimizing a CNN can be cumbersome. While running the CNN on a GTX 660M, we were not able to manage to get satisfying results. Most likely we would have needed more training time on the batches to receive better results. When we switched to a Tesla K80 we managed to train the network with larger amounts of data and a higher batch size. This resulted in higher accuracy on the simple and more complex datasets. We realized that memory poses a quite severe limitation towards applying large scale machine learning.\\nOur approach based on a CNN is limited to CAPTCHAs with exactly the length defined in the network. Hence, classifying CAPTCHAs with any other length than five would fail. As an alternative a RNN could be used to resolve this issue. In [8] a use of RNN to break CAPTCHAs is discussed with fairly good results. However, also in this approach a powerful GPU is required.\\nMoreover, using a CNN requires large datasets to be trained on. For a combination of digits, characters, and rotation we required a dataset of around 200000 CAPTCHAs (~780MB). On small sized GPU this datasets cause either out of memory errors or require a quite long training time. Even with the Tesla K80 the training time takes around 2 hours and 30 minutes.\\n\\n\\n## References\\n\\n1. Goodfellow, Ian J., et al. \\"Multi-digit number recognition from street view imagery using deep convolutional neural networks.\\" arXiv preprint arXiv:1312.6082 (2013).\\n2. Hong, Colin et al. \\"Breaking Microsoft\u2019s CAPTCHA.\\" (2015).\\n3. Using deep learning to break a CAPTCHA system in Deep Learning. 3 Jan. 2016, https://deepmlblog.wordpress.com/2016/01/03/how-to-break-a-CAPTCHA-system/. Accessed 6 Dec. 2016.\\n4. Stark, Fabian, et al. \\"CAPTCHA Recognition with Active Deep Learning.\\" Workshop New Challenges in Neural Computation 2015. 2015.\\n5. Von Ahn, Luis, et al. \\"CAPTCHA: Using hard AI problems for security.\\" International Conference on the Theory and Applications of Cryptographic Techniques. Springer Berlin Heidelberg, 2003.\\n6. \\"CAPTCHA: Telling Humans and Computers Apart Automatically\\" 2010, http://www.CAPTCHA.net/. Accessed 7 Jan. 2017.\\n7. Elie Bursztein et al., \\"The end is nigh: generic solving of text-based CAPTCHAs\\". Proceedings of the 8th USENIX conference on Offensive Technologies, p.3-3, August 19, 2014, San Diego, CA\\n8. Recurrent neural networks for decoding CAPTCHAs in Deep Learning. 12 Jan. 2016, https://deepmlblog.wordpress.com/2016/01/12/recurrent-neural-networks-for-decoding-CAPTCHAs/. Accessed 9 Jan. 2017.\\n9. CAPTCHA Alternatives and thoughts. 15 Dec. 2015, https://www.w3.org/WAI/GL/wiki/CAPTCHA_Alternatives_and_thoughts. Accessed 9 Jan. 2017."},{"id":"dinvest-hedge-fund-on-a-blockchain","metadata":{"permalink":"/blog/dinvest-hedge-fund-on-a-blockchain","editUrl":"https://github.com/nud3l/nud3l.github.io/blog/2017-01-10-dinvest.md","source":"@site/blog/2017-01-10-dinvest.md","title":"dInvest - hedge fund on a blockchain","description":"As public reputation becomes one of the most important success factors beyond financial success, investment opportunity should ensure ethical decisions and keep sustainable investment as core of their strategy. These long-term investment strategies based on criteria other than pure financial data are summarized under \\"Value Investment\\". Value investment is based on the assumption that the current price of an asset might not be the actual value of an asset (e.g.\xa0stocks and derivatives). Thus, criteria other than their current prices can be taken into account to calculate their value. The value investing approach offers thereby methods to select potential investment based on social or sustainability criteria. Furthermore, value investment includes diversification of the portfolio to achieve a desired level of risk.","date":"2017-01-10T00:00:00.000Z","formattedDate":"January 10, 2017","tags":[{"label":"dinvest","permalink":"/blog/tags/dinvest"},{"label":"blockchain","permalink":"/blog/tags/blockchain"},{"label":"DeFi","permalink":"/blog/tags/de-fi"}],"readingTime":3.645,"hasTruncateMarker":false,"authors":[{"name":"Dominik Harz","title":"CTO Interlay","url":"https://harz.dev","imageURL":"https://github.com/nud3l.png","key":"dom"}],"frontMatter":{"slug":"dinvest-hedge-fund-on-a-blockchain","title":"dInvest - hedge fund on a blockchain","tags":["dinvest","blockchain","DeFi"],"authors":"dom"},"prevItem":{"title":"Breaking captchas: Using deep learning to automatically break CAPTCHAs","permalink":"/blog/breaking-captchas"}},"content":"As public reputation becomes one of the most important success factors beyond financial success, investment opportunity should ensure ethical decisions and keep sustainable investment as core of their strategy. These long-term investment strategies based on criteria other than pure financial data are summarized under \\"Value Investment\\". Value investment is based on the assumption that the current price of an asset might not be the actual value of an asset (e.g.\xa0stocks and derivatives). Thus, criteria other than their current prices can be taken into account to calculate their value. The value investing approach offers thereby methods to select potential investment based on social or sustainability criteria. Furthermore, value investment includes diversification of the portfolio to achieve a desired level of risk.\\n\\nIn this blog post I will introduce dInvest, a project [Tharidu](https://se.linkedin.com/in/tharidu-fernando) and me are working on. With the development of blockchain technologies and the Ethereum blockchain, an autonomous and decentralized approach can be taken to create an investment opportunity. Users are able to invest directly with the cryptocurrency Ether into a company which exists in the Ethereum blockchain. Alternatively, they can invest with other cryptocurrencies (e.g.\xa0Bitcoin) or fiat currencies by utilizing currency exchanges. An autonomous organization build on Smart Contracts exists solely as code and can execute the details as specified in the contract. As an example, The DAO enabled users to act as venture capitalists by suggesting investments to other users. If a certain amount of investments was raised the contracts would be executed inside the blockchain. However, this approach failed as The DAO suffered security flaws, which led to a severe attack on its system. Furthermore, The DAO failed to give incentives to users proposing investments. Investments are voted for two weeks, while a vote can only be given by bounding a user\u2019s capital into the vote. Thus, late voting and waiting for other\u2019s resulted in available capital.\\n\\n\\n## Problem\\n\\nCertain investors want to invest their money in order to gain returns while being socially responsible and sustainable to e.g.\xa0achieve corporate sustainability objectives. However, financial intermediaries, such as investment banks or hedge funds, do not always adhere to investors\u2019 requirements as there might be conflicting interests. Furthermore, the investment strategy applied by the financial intermediary can change through time and is highly influenced by social factors. In addition to that, investors do not have complete transparency over the transactions.\\n\\n## Our work\\n\\nWe decided to develop an autonomous hedge fund in the Ethereum blockchain. Users are represented in the Ropsten network of the Ethereum blockchain as addresses. Users can hold certain amounts of test Ether, which they can invest into dInvest. The investment will contain an amount of Ether and a time period defined by the user. The details of the investment will be defined in a smart contract between the user and dInvest. Selecting stocks for different investment amounts and time periods is comparably computation intensive and will require the application of investment algorithms. Thus, their executing is costly in the blockchain and will therefore be executed by an autonomous agent (invest agent) outside of the blockchain. The required information will be passed on to dInvest on demand and therefore keeping the operational cost to a minimum.\\nThe invest agent will suggest investment strategies to the hedge fund according to the current Ether value. The hedge fund will decide to approve or reject the offer based on the sustainability criteria of users\u2019 investments. Only if the criteria is fulfilled, the Ether will be transferred to the buy agent and make the investment. The invest agent will transfer the investment return to the hedge fund where the profit/loss will be divided to investors according to their investment value.\\n\\nWe managed to achieve a linear cost function of user investments and their sustainability criteria in the smart contract. Based on a value investment investment strategy we managed to achieve around 360% increase of the portfolio in a back-testing simulation over around 6 years. The sustainability criteria was implemented using exclusion of assets based on industry codes (i.e. exclusion of defense, alcohol, tobacco, or coal industries).\\nIf you are interested in the academic side and the results of our implementation, you can check out our [report](https://goo.gl/T74EGE).\\nAs the paper does not cover the implementation in detail, I will post the details in separate blog posts and link them here. You can also check out our [source code on GitHub](github.com/nud3l/dInvest)."}]}')}}]);